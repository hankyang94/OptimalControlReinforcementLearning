<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>A Convex Analysis and Optimization | Optimal Control and Reinforcement Learning</title>
  <meta name="description" content="Lecture notes for Harvard ES/AM 158 Introduction to Optimal Control and Reinforcement Learning." />
  <meta name="generator" content="bookdown 0.44 and GitBook 2.6.7" />

  <meta property="og:title" content="A Convex Analysis and Optimization | Optimal Control and Reinforcement Learning" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="Lecture notes for Harvard ES/AM 158 Introduction to Optimal Control and Reinforcement Learning." />
  <meta name="github-repo" content="hankyang94/OptimalControlReinforcementLearning" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="A Convex Analysis and Optimization | Optimal Control and Reinforcement Learning" />
  
  <meta name="twitter:description" content="Lecture notes for Harvard ES/AM 158 Introduction to Optimal Control and Reinforcement Learning." />
  

<meta name="author" content="Heng Yang" />


<meta name="date" content="2025-09-16" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="policy-gradient.html"/>
<link rel="next" href="app-lti-system-theory.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>
<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Optimal Control and Reinforcement Learning</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#feedback"><i class="fa fa-check"></i>Feedback</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#offerings"><i class="fa fa-check"></i>Offerings</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="mdp.html"><a href="mdp.html"><i class="fa fa-check"></i><b>1</b> Markov Decision Process</a>
<ul>
<li class="chapter" data-level="1.1" data-path="mdp.html"><a href="mdp.html#FiniteHorizonMDP"><i class="fa fa-check"></i><b>1.1</b> Finite-Horizon MDP</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="mdp.html"><a href="mdp.html#FiniteHorizonMDP-Value"><i class="fa fa-check"></i><b>1.1.1</b> Value Functions</a></li>
<li class="chapter" data-level="1.1.2" data-path="mdp.html"><a href="mdp.html#policy-evaluation"><i class="fa fa-check"></i><b>1.1.2</b> Policy Evaluation</a></li>
<li class="chapter" data-level="1.1.3" data-path="mdp.html"><a href="mdp.html#optimality"><i class="fa fa-check"></i><b>1.1.3</b> Principle of Optimality</a></li>
<li class="chapter" data-level="1.1.4" data-path="mdp.html"><a href="mdp.html#dp"><i class="fa fa-check"></i><b>1.1.4</b> Dynamic Programming</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="mdp.html"><a href="mdp.html#InfiniteHorizonMDP"><i class="fa fa-check"></i><b>1.2</b> Infinite-Horizon MDP</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="mdp.html"><a href="mdp.html#value-functions"><i class="fa fa-check"></i><b>1.2.1</b> Value Functions</a></li>
<li class="chapter" data-level="1.2.2" data-path="mdp.html"><a href="mdp.html#policy-evaluation-1"><i class="fa fa-check"></i><b>1.2.2</b> Policy Evaluation</a></li>
<li class="chapter" data-level="1.2.3" data-path="mdp.html"><a href="mdp.html#principle-of-optimality"><i class="fa fa-check"></i><b>1.2.3</b> Principle of Optimality</a></li>
<li class="chapter" data-level="1.2.4" data-path="mdp.html"><a href="mdp.html#policy-improvement"><i class="fa fa-check"></i><b>1.2.4</b> Policy Improvement</a></li>
<li class="chapter" data-level="1.2.5" data-path="mdp.html"><a href="mdp.html#policy-iteration"><i class="fa fa-check"></i><b>1.2.5</b> Policy Iteration</a></li>
<li class="chapter" data-level="1.2.6" data-path="mdp.html"><a href="mdp.html#value-iteration"><i class="fa fa-check"></i><b>1.2.6</b> Value Iteration</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="value-rl.html"><a href="value-rl.html"><i class="fa fa-check"></i><b>2</b> Value-based Reinforcement Learning</a>
<ul>
<li class="chapter" data-level="2.1" data-path="value-rl.html"><a href="value-rl.html#tabular-methods"><i class="fa fa-check"></i><b>2.1</b> Tabular Methods</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="value-rl.html"><a href="value-rl.html#policy-evaluation-2"><i class="fa fa-check"></i><b>2.1.1</b> Policy Evaluation</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="value-rl.html"><a href="value-rl.html#function-approximation"><i class="fa fa-check"></i><b>2.2</b> Function Approximation</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="policy-gradient.html"><a href="policy-gradient.html"><i class="fa fa-check"></i><b>3</b> Policy Gradients</a></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="A" data-path="appconvex.html"><a href="appconvex.html"><i class="fa fa-check"></i><b>A</b> Convex Analysis and Optimization</a>
<ul>
<li class="chapter" data-level="A.1" data-path="appconvex.html"><a href="appconvex.html#appconvex-theory"><i class="fa fa-check"></i><b>A.1</b> Theory</a>
<ul>
<li class="chapter" data-level="A.1.1" data-path="appconvex.html"><a href="appconvex.html#sets"><i class="fa fa-check"></i><b>A.1.1</b> Sets</a></li>
<li class="chapter" data-level="A.1.2" data-path="appconvex.html"><a href="appconvex.html#appconvex-theory-convexfunction"><i class="fa fa-check"></i><b>A.1.2</b> Convex function</a></li>
<li class="chapter" data-level="A.1.3" data-path="appconvex.html"><a href="appconvex.html#lagrange-dual"><i class="fa fa-check"></i><b>A.1.3</b> Lagrange dual</a></li>
<li class="chapter" data-level="A.1.4" data-path="appconvex.html"><a href="appconvex.html#appconvex-theory-kkt"><i class="fa fa-check"></i><b>A.1.4</b> KKT condition</a></li>
</ul></li>
<li class="chapter" data-level="A.2" data-path="appconvex.html"><a href="appconvex.html#appconvex-practice"><i class="fa fa-check"></i><b>A.2</b> Practice</a>
<ul>
<li class="chapter" data-level="A.2.1" data-path="appconvex.html"><a href="appconvex.html#cvx-introduction"><i class="fa fa-check"></i><b>A.2.1</b> CVX Introduction</a></li>
<li class="chapter" data-level="A.2.2" data-path="appconvex.html"><a href="appconvex.html#linear-programming-lp"><i class="fa fa-check"></i><b>A.2.2</b> Linear Programming (LP)</a></li>
<li class="chapter" data-level="A.2.3" data-path="appconvex.html"><a href="appconvex.html#quadratic-programming-qp"><i class="fa fa-check"></i><b>A.2.3</b> Quadratic Programming (QP)</a></li>
<li class="chapter" data-level="A.2.4" data-path="appconvex.html"><a href="appconvex.html#quadratically-constrained-quadratic-programming-qcqp"><i class="fa fa-check"></i><b>A.2.4</b> Quadratically Constrained Quadratic Programming (QCQP)</a></li>
<li class="chapter" data-level="A.2.5" data-path="appconvex.html"><a href="appconvex.html#second-order-cone-programming-socp"><i class="fa fa-check"></i><b>A.2.5</b> Second-Order Cone Programming (SOCP)</a></li>
<li class="chapter" data-level="A.2.6" data-path="appconvex.html"><a href="appconvex.html#semidefinite-programming-sdp"><i class="fa fa-check"></i><b>A.2.6</b> Semidefinite Programming (SDP)</a></li>
<li class="chapter" data-level="A.2.7" data-path="appconvex.html"><a href="appconvex.html#cvxpy-introduction-and-examples"><i class="fa fa-check"></i><b>A.2.7</b> CVXPY Introduction and Examples</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="B" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html"><i class="fa fa-check"></i><b>B</b> Linear System Theory</a>
<ul>
<li class="chapter" data-level="B.1" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#app-lti-stability"><i class="fa fa-check"></i><b>B.1</b> Stability</a>
<ul>
<li class="chapter" data-level="B.1.1" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#app-lti-stability-ct"><i class="fa fa-check"></i><b>B.1.1</b> Continuous-Time Stability</a></li>
<li class="chapter" data-level="B.1.2" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#app-lti-stability-dt"><i class="fa fa-check"></i><b>B.1.2</b> Discrete-Time Stability</a></li>
<li class="chapter" data-level="B.1.3" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#lyapunov-analysis"><i class="fa fa-check"></i><b>B.1.3</b> Lyapunov Analysis</a></li>
</ul></li>
<li class="chapter" data-level="B.2" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#app-lti-controllable-observable"><i class="fa fa-check"></i><b>B.2</b> Controllability and Observability</a>
<ul>
<li class="chapter" data-level="B.2.1" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#cayley-hamilton-theorem"><i class="fa fa-check"></i><b>B.2.1</b> Cayley-Hamilton Theorem</a></li>
<li class="chapter" data-level="B.2.2" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#equivalent-statements-for-controllability"><i class="fa fa-check"></i><b>B.2.2</b> Equivalent Statements for Controllability</a></li>
<li class="chapter" data-level="B.2.3" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#duality"><i class="fa fa-check"></i><b>B.2.3</b> Duality</a></li>
<li class="chapter" data-level="B.2.4" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#equivalent-statements-for-observability"><i class="fa fa-check"></i><b>B.2.4</b> Equivalent Statements for Observability</a></li>
</ul></li>
<li class="chapter" data-level="B.3" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#stabilizability-and-detectability"><i class="fa fa-check"></i><b>B.3</b> Stabilizability And Detectability</a>
<ul>
<li class="chapter" data-level="B.3.1" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#equivalent-statements-for-stabilizability"><i class="fa fa-check"></i><b>B.3.1</b> Equivalent Statements for Stabilizability</a></li>
<li class="chapter" data-level="B.3.2" data-path="app-lti-system-theory.html"><a href="app-lti-system-theory.html#equivalent-statements-for-detectability"><i class="fa fa-check"></i><b>B.3.2</b> Equivalent Statements for Detectability</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Optimal Control and Reinforcement Learning</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="appconvex" class="section level1 hasAnchor" number="4">
<h1><span class="header-section-number">A</span> Convex Analysis and Optimization<a href="appconvex.html#appconvex" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="appconvex-theory" class="section level2 hasAnchor" number="4.1">
<h2><span class="header-section-number">A.1</span> Theory<a href="appconvex.html#appconvex-theory" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="sets" class="section level3 hasAnchor" number="4.1.1">
<h3><span class="header-section-number">A.1.1</span> Sets<a href="appconvex.html#sets" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Convex set is one of the most important concepts in convex optimization. Checking convexity of sets is crucial to determining whether a problem is a convex problem. Here we will present some definitions of some set notations in convex optimization.</p>
<div class="definitionbox">
<div class="definition">
<p><span id="def:affineset" class="definition"><strong>Definition A.1  (Affine set) </strong></span>A set <span class="math inline">\(C\subset \mathbb{R}^n\)</span> is affine if the line through any two distinct points in <span class="math inline">\(C\)</span> lies in <span class="math inline">\(C\)</span>, i.e., if for any <span class="math inline">\(x_1,x_2 \in C\)</span> and any <span class="math inline">\(\theta \in \mathbb{R}\)</span>, we have <span class="math inline">\(\theta x_1 + (1-\theta)x_2 \in C\)</span>.</p>
</div>
</div>
<div class="definitionbox">
<div class="definition">
<p><span id="def:convexset" class="definition"><strong>Definition A.2  (Convex set) </strong></span>A set <span class="math inline">\(C\subset \mathbb{R}^n\)</span> is convex if the line segment between any two distinct points in <span class="math inline">\(C\)</span> lies in <span class="math inline">\(C\)</span>, i.e., if for any <span class="math inline">\(x_1,x_2 \in C\)</span> and any <span class="math inline">\(\theta \in [0,1]\)</span>, we have <span class="math inline">\(\theta x_1 + (1-\theta)x_2 \in C\)</span>.</p>
</div>
</div>
<div class="definitionbox">
<div class="definition">
<p><span id="def:cone" class="definition"><strong>Definition A.3  (Cone) </strong></span>A set <span class="math inline">\(C\subset \mathbb{R}^n\)</span> is a cone if for any <span class="math inline">\(x\in C\)</span> and any <span class="math inline">\(\theta\geq 0\)</span>, we have <span class="math inline">\(\theta x \in C\)</span>.</p>
</div>
</div>
<div class="definitionbox">
<div class="definition">
<p><span id="def:convexcone" class="definition"><strong>Definition A.4  (Convex Cone) </strong></span>A set <span class="math inline">\(C\subset \mathbb{R}^n\)</span> is a convex cone if <span class="math inline">\(C\)</span> is convex and a cone.</p>
</div>
</div>
<p>Below are some important examples of convex sets:</p>
<div class="definitionbox">
<div class="definition">
<p><span id="def:hyperplane" class="definition"><strong>Definition A.5  (Hyperplane) </strong></span>A hyperplane is a set of the form <span class="math display">\[\{x|a^Tx = b\}\]</span></p>
</div>
</div>
<div class="definitionbox">
<div class="definition">
<p><span id="def:halfspaces" class="definition"><strong>Definition A.6  (Halfspaces) </strong></span>A (closed) halfspace is a set of the form <span class="math display">\[\{x|a^Tx \leq b\}\]</span></p>
</div>
</div>
<div class="definitionbox">
<div class="definition">
<p><span id="def:balls" class="definition"><strong>Definition A.7  (Balls) </strong></span>A ball is a set of the form <span class="math display">\[B(x,r) = \{y|\|y-x\|_2 \leq r\} = \{x+ru|\|u\|_2\leq 1\}\]</span>
where <span class="math inline">\(r &gt;0\)</span>.</p>
</div>
</div>
<div class="definitionbox">
<div class="definition">
<p><span id="def:ellipsoids" class="definition"><strong>Definition A.8  (Ellipsoids) </strong></span>A ellipsoid is a set of the form <span class="math display">\[\mathcal{E} = \{y|(y-x)^TP^{-1}(y-x)\leq 1\}\]</span>
where <span class="math inline">\(P\)</span> is symmetric and positive definite.</p>
</div>
</div>
<div class="definitionbox">
<div class="definition">
<p><span id="def:polyhedra" class="definition"><strong>Definition A.9  (Polyhedra) </strong></span>A polyhedra is defined as the solution set of a finite number of linear equalities
and inequalities: <span class="math display">\[\mathcal{P} = \{x|a_j^Tx\leq b_j, j=1,...,m, c_k^Tx=d_k,k=1,...,p\}\]</span></p>
</div>
</div>
<div class="definitionbox">
<div class="definition">
<p><span id="def:normball" class="definition"><strong>Definition A.10  (Norm ball) </strong></span>A norm ball <span class="math inline">\(B\)</span> of radius <span class="math inline">\(r\)</span> and a center <span class="math inline">\(x_c\)</span> associated with the norm <span class="math inline">\(\|\cdot\|\)</span> is defined as: <span class="math display">\[B = \{x|\|x-x_c\|\leq r\}\]</span></p>
</div>
</div>
<div class="definitionbox">
<div class="definition">
<p><span id="def:normcone" class="definition"><strong>Definition A.11  (Norm cone) </strong></span>A norm cone <span class="math inline">\(C\)</span> associated with the norm <span class="math inline">\(\|\cdot\|\)</span> is defined as: <span class="math display">\[C = \{(x,t)|\|x\|\leq t\}\subset \mathbb{R}^{n+1}\]</span></p>
</div>
</div>
<p>Simplexes are important family of polyhedra. Suppose the <span class="math inline">\(k+1\)</span> points <span class="math inline">\(v_0,...,v_k\in \mathbb{R}^n\)</span> are affinely independent, which means <span class="math inline">\(v_1-v_0,...,v_k-v_0\)</span> are linearly independent.</p>
<div class="definitionbox">
<div class="definition">
<p><span id="def:simplex" class="definition"><strong>Definition A.12  (Simplex) </strong></span>A simplex <span class="math inline">\(C\)</span> defined by points <span class="math inline">\(v_0,...,v_k\)</span> is: <span class="math display">\[C = \textbf{conv}\{v_0,...,v_k\} = \{\theta_0v_0 + ... \theta_kv_k|\theta \succeq 0, \textbf{1}^T\theta = 1\}\]</span></p>
</div>
</div>
<p>Extremely important examples of convex sets are positive semidefinite cones:</p>
<div class="definitionbox">
<div class="definition">
<p><span id="def:symmetricmatrices" class="definition"><strong>Definition A.13  (Symmetric,positive semidefinite,positive definite matrices) </strong></span></p>
<ol style="list-style-type: decimal">
<li>Symmetric matrices: <span class="math inline">\(\textbf{S}^n = \{X\in\mathbb{R}^{n\times n}| X=X^T\}\)</span></li>
<li>Symmetric Positive Semidefinite matrices: <span class="math inline">\(\textbf{S}_+^n = \{X\in\textbf{S}^n| X\succeq0\}\)</span></li>
<li>Symmetric Positive definite matrices: <span class="math inline">\(\textbf{S}_{++}^n = \{X\in\textbf{S}^n| X\succ0\}\)</span></li>
</ol>
</div>
</div>
<p>In most scenarios, the set we encounter is more complicated. In general it is extermely hard to determine whether a set in convex or not. But if the set is ‘generated’ by some convex sets, we can easily determine its convexity. So let’s focus on operations that preserve convexity:</p>
<div class="theorembox">
<div class="proposition">
<p><span id="prp:operationpreserveconvexity" class="proposition"><strong>Proposition A.1  </strong></span>Assume <span class="math inline">\(S\)</span> is convex, <span class="math inline">\(S_\alpha,\alpha\in\mathcal{A}\)</span> is a family of convex sets. Following operations on convex sets will preserve convexity:</p>
<ol style="list-style-type: decimal">
<li><p>Intersection: <span class="math inline">\(\bigcap_{\alpha\in\mathcal{A}}S_\alpha\)</span> is convex.</p></li>
<li><p>Image under affine function: A function <span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}^m\)</span> is affine if it has the form <span class="math inline">\(f(x) = Ax+b\)</span>. The image of <span class="math inline">\(S\)</span> under affine function <span class="math inline">\(f\)</span> is convex. I.e. <span class="math inline">\(f(S) = \{f(x)|x\in S\}\)</span> is convex</p></li>
<li><p>Image under perspective function: We define the perspective function <span class="math inline">\(P:\mathbb{R}^{n+1}\)</span>, with domain <span class="math inline">\(\textbf{dom}P = \mathbb{R}^n\times \mathbb{R}_{++}\)</span>(where <span class="math inline">\(\mathbb{R}_{++}=\{x\in \mathbb{R}|x&gt;0\}\)</span>) as <span class="math inline">\(P(z,t) = z/t\)</span>. The image of <span class="math inline">\(S\)</span> under perspective function is convex.</p></li>
<li><p>Image under linear-fractional function: We define linear fractional function <span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}^m\)</span> as:<span class="math inline">\(f(x) = (Ax+b)/(c^Tx+d)\)</span> with <span class="math inline">\(\textbf{dom}f = \{x|c^Tx+d&gt;0\|\)</span>. The image of <span class="math inline">\(S\)</span> under linear fractional functions is convex.</p></li>
</ol>
</div>
</div>
<p>In some cases, the restrictions of <strong>interior</strong> is too strict. For example, imagine a plane in <span class="math inline">\(\mathbb{R}^3\)</span>. The interior of the plane is <span class="math inline">\(\emptyset\)</span>. But intuitively many property should be extended to this kind of situation. Because the points in the plane also lies ‘inside’ the convex set. Thus, we will define <strong>relative interior</strong>. First we will define <strong>affine hull</strong>.</p>
<div class="definitionbox">
<div class="definition">
<p><span id="def:affinehull" class="definition"><strong>Definition A.14  (Affine hull) </strong></span>The affine hull of a set <span class="math inline">\(S\)</span> is the smallest affine set that contains <span class="math inline">\(S\)</span>, which can be written as:
<span class="math display">\[\text{aff}(S) = \{\sum_{i=1}^k\alpha_ix_i|k&gt;0,x_i\in S,\alpha_i\in\mathbb{R},\sum_{i=1}^k\alpha_i=1\}\]</span></p>
</div>
</div>
<div class="definitionbox">
<div class="definition">
<p><span id="def:relint" class="definition"><strong>Definition A.15  (Relative Interior) </strong></span>The relative interior of a set <span class="math inline">\(S\)</span> (denoted <span class="math inline">\(\text{relint}(S)\)</span>) is defined as its interior within the affine hull of <span class="math inline">\(S\)</span>. I.e.
<span class="math display">\[\text{relint}(S):=\{x\in S: \text{there exists } \epsilon&gt;0 \text{ such that }N_\epsilon \cap \text{aff}(S)\subset S\}\]</span>
where <span class="math inline">\(N_\epsilon(x)\)</span> is a ball of radius <span class="math inline">\(\epsilon\)</span> centered on <span class="math inline">\(x\)</span>.</p>
</div>
</div>
</div>
<div id="appconvex-theory-convexfunction" class="section level3 hasAnchor" number="4.1.2">
<h3><span class="header-section-number">A.1.2</span> Convex function<a href="appconvex.html#appconvex-theory-convexfunction" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In this section, let’s define convex functions:</p>
<div class="definitionbox">
<div class="definition">
<p><span id="def:defcvxfunc" class="definition"><strong>Definition A.16  (Convex function) </strong></span>A function <span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}\)</span> is <strong>convex</strong> if <span class="math inline">\(\textbf{dom}\ f\)</span> is convex and <span class="math inline">\(\forall x,y\in \textbf{dom}\ f\)</span> and with <span class="math inline">\(\theta \in [0,1]\)</span>, we have:<span class="math display">\[f(\theta x +(1-\theta)y)\leq \theta f(x) + (1-\theta)f(y)\]</span>
The function is <strong>strictly convex</strong> if the inequality holds whenever <span class="math inline">\(x\neq y\)</span> and <span class="math inline">\(\theta\in (0,1)\)</span>.</p>
</div>
</div>
<p>If a function is differentiable, it will be easier for us to check its convexity:</p>
<div class="theorembox">
<div class="proposition">
<p><span id="prp:decidecvx" class="proposition"><strong>Proposition A.2  (Conditions for Convex function) </strong></span>1.(First order condition) Suppose <span class="math inline">\(f\)</span> is differentiable, then <span class="math inline">\(f\)</span> is convex if and only if <span class="math inline">\(\textbf{dom} f\)</span> is convex and <span class="math inline">\(\forall x,y\in \textbf{dom} f\)</span>, <span class="math display">\[f(y)\geq f(x) +\nabla f(x)^T(y-x)\]</span>
2.(Second order conditions) Suppose <span class="math inline">\(f\)</span> is twice differentiable, then <span class="math inline">\(f\)</span> is convex if and only if <span class="math inline">\(\textbf{dom} f\)</span> is convex and <span class="math inline">\(\forall x\in \textbf{dom} f\)</span>, <span class="math display">\[\nabla^2 f(x) \succeq \textbf{0}\]</span></p>
</div>
</div>
<p>For the same purpose, some operations that preserve the convexity of the convex functions are presented here:</p>
<div class="theorembox">
<div class="proposition">
<p><span id="prp:preservecvx" class="proposition"><strong>Proposition A.3  (Operations that preserve convexity) </strong></span>Let <span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}\)</span> be a convex function and <span class="math inline">\(g_1,...,g_n\)</span> be convex functions. The following operations will preserve convexity of the function:</p>
<p>1.(Nonnegative weighted sum): A nonnegative weighted sum of convex functions: <span class="math display">\[f = \omega_1f_1 + ... +\omega_mf_m\]</span></p>
<p>2.(Composition with an affine mapping) Suppose <span class="math inline">\(A\in \mathbb{R}^{n\times m}\)</span> and <span class="math inline">\(b\in \mathbb{R}^n\)</span>, then <span class="math inline">\(g(x) = f(Ax+b)\)</span> is convex.</p>
<p>3.(Pointwise maximum and supremum) <span class="math inline">\(g(x) = \max\{g_1(x),...,g_n(x)\}\)</span> is convex. If <span class="math inline">\(h(x,y)\)</span> is convex in <span class="math inline">\(x\)</span> for each <span class="math inline">\(y\in\mathcal{A}\)</span>, then <span class="math inline">\(\sup_{y\in\mathcal{A}} h(x,y)\)</span> is also convex in <span class="math inline">\(x\)</span>.</p>
<p>4.(Minimization) If <span class="math inline">\(h(x,y)\)</span> is convex in <span class="math inline">\((x,y)\)</span>, and <span class="math inline">\(C\)</span> is a convex nonempty set, then <span class="math inline">\(\inf_{x\in C} h(x,y)\)</span> is convex in <span class="math inline">\(x\)</span>.</p>
<p>5.(Perspective of a function) The perspective of <span class="math inline">\(f\)</span> is the function <span class="math inline">\(h:\mathbb{R}^{n+1}\to\mathbb{R}\)</span> defined by: <span class="math inline">\(h(x,t) = tf(x/t)\)</span> with domain <span class="math inline">\(\textbf{dom}\ h=\{(x,t)|x/t\in\textbf{dom} f,t&gt;0\}\)</span>. And <span class="math inline">\(h\)</span> is convex.</p>
</div>
</div>
</div>
<div id="lagrange-dual" class="section level3 hasAnchor" number="4.1.3">
<h3><span class="header-section-number">A.1.3</span> Lagrange dual<a href="appconvex.html#lagrange-dual" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We consider an optimization problem in the standard form (without assuming convexity of anything):
<span class="math display">\[\begin{equation}
\begin{aligned}
p^* = \quad \min_{x} \quad &amp; f_0(x)\\
\textrm{s.t.} \quad &amp; f_i(x)\leq 0\quad i=1...,m\\
  &amp; h_i(x) = 0\quad i=1,...,p   \\
\end{aligned}
\end{equation}\]</span></p>
<div class="definitionbox">
<div class="definition">
<p><span id="def:defdualfunc" class="definition"><strong>Definition A.17  (Lagrange dual function) </strong></span>The Lagrangian related to the problem above is defined as: <span class="math display">\[L(x,\lambda,\nu)=f_0(x)+\sum_{i=1}^m\lambda_if_i(x)+\sum_{i=1}^p\nu_ih_i(x)\]</span>
The Lagrange dual function is defined as: <span class="math display">\[g(\lambda,\nu) = \inf_{x\in\mathcal{D}}L(x,\lambda,\nu)\]</span></p>
</div>
</div>
<p>When the Lagrangian is unbounded below in <span class="math inline">\(x\)</span>, the dual function takes on the value <span class="math inline">\(-\infty\)</span>. Note that since the Lagrange dual function is a pointwise infimum of a family of affine functions of <span class="math inline">\((\lambda,\nu)\)</span>, so it’s concave. The Lagrange dual function will give us lower bounds of the optimal value of the original problem: <span class="math display">\[g(\lambda,\nu)\leq p^*\]</span>. We can see that, the dual function can give a nontrivial lower bound only when <span class="math inline">\(\lambda\succeq 0\)</span>. Thus we can solve the following dual problem to get the best lower bound.</p>
<div class="definitionbox">
<div class="definition">
<p><span id="def:defdualprob" class="definition"><strong>Definition A.18  (Lagrange dual problem) </strong></span>The lagrangian dual problem is defined as follows:
<span class="math display">\[\begin{equation}
  \begin{aligned}
  d^* = \quad \max_{\lambda,\nu} \quad &amp; g(\lambda,\nu)\\
  \textrm{s.t.} \quad &amp; \lambda\succeq 0
  \end{aligned}
  \end{equation}\]</span>
This is a convex optimization problem.</p>
</div>
</div>
<p>We can easily see that <span class="math display">\[d^*\leq p^*\]</span> always hold. This property is called <strong>weak duality</strong>. If <span class="math display">\[d^*=p^*\]</span>, it’s called <strong>strong duality</strong>. Strong duality does not hold in general, but it usually holfs for convex problems. We can find conditions that guarantee strong duality in convex problems, which are called constrained qualifications. Slater’s constraint qualification is a useful one.</p>
<div class="theorembox">
<div class="theorem">
<p><span id="thm:slater" class="theorem"><strong>Theorem A.1  (Slater's constraint qualification) </strong></span>Strong duality holds for a convex problem
<span class="math display">\[\begin{equation}
  \begin{aligned}
  p^* = \quad \min_{x} \quad &amp; f_0(x)\\
  \textrm{s.t.} \quad &amp; f_i(x)\leq 0\quad i=1...,m\\
    &amp; Ax=b   \\
  \end{aligned}
\end{equation}\]</span>
if it is strictly feasible, i.e.
<span class="math display">\[\exists x\in\textbf{relint}\mathcal{D}:\quad f_i(x)&lt;0,\quad i=1...m,\quad Ax=b\]</span>
And the linear inequalities do not need to hold with strict inequality.</p>
</div>
</div>
</div>
<div id="appconvex-theory-kkt" class="section level3 hasAnchor" number="4.1.4">
<h3><span class="header-section-number">A.1.4</span> KKT condition<a href="appconvex.html#appconvex-theory-kkt" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Note that if strong duality holds, denote <span class="math inline">\(x^*\)</span> to be primal optimal, and <span class="math inline">\((\lambda^*,\nu^*)\)</span> to be dual optimal. Then:</p>
<p><span class="math display">\[\begin{equation}
  \begin{aligned}
  f_0(x^*) = g(\lambda^*,\nu^*) = &amp; \inf_x(f_0(x)+\sum_{i=1}^m\lambda_i^*f_i(x)+\sum_{i=1}^p\nu_i^*h_i(x))\\
\leq &amp; f_0(x^*)+\sum_{i=1}^m\lambda_i^*f_i(x)+\sum_{i=1}^p\nu_i^*h_i(x)\\
\leq &amp; f_0(x^*)\\
  \end{aligned}
  \end{equation}\]</span></p>
<p>from this, combining <span class="math inline">\(\lambda^*\geq 0\)</span> and <span class="math inline">\(f_i(x^*)\leq 0\)</span>, we can know that: <span class="math inline">\(\lambda_i^*f_i(x^*)=0\quad i=1\cdots m\)</span>. This means for <span class="math inline">\(\lambda_i^*\)</span> and <span class="math inline">\(f_i(x^*)\)</span>, one of them must be zero, which is known as complementary slackness).</p>
<p>Thus we arrived at the following four conditions, which are called KKT conditions.</p>
<div class="theorembox">
<div class="theorem">
<p><span id="thm:KKT" class="theorem"><strong>Theorem A.2  (Karush-Kuhn-Tucker(KKT) Conditions) </strong></span>The following four conditions are called KKT conditions (for a problem with differentiable <span class="math inline">\(f_i,h_i\)</span>)</p>
<ol style="list-style-type: decimal">
<li>Primal feasible: <span class="math inline">\(f_i(x) \leq 0,i,\cdots ,m,\ h_i(x) = 0,i=1,\cdots ,p\)</span></li>
<li>Dual feasible: <span class="math inline">\(\lambda\succeq0\)</span></li>
<li>Complementary slackness: <span class="math inline">\(\lambda_if_i(x)=0,i=1,\cdots,m\)</span></li>
<li>Gradient of Lagrangian with respect to <span class="math inline">\(x\)</span> vanishes:<span class="math inline">\(\nabla f_0(x)+\sum_{i=1}^m\lambda_i\nabla f_i(x)+\sum_{i=1}^p\nu_i\nabla h_i(x) = 0\)</span></li>
</ol>
</div>
</div>
<p>From the discussion above, we know that if strong duality holds and <span class="math inline">\(x,\lambda,\nu\)</span> are optimal, then they must satisfy the KKT conditions.</p>
<p>Also if <span class="math inline">\(x,\lambda,\nu\)</span> satisfy KKT for a convex problem, then they are optimal. However, the converse is not generally true, since KKT condition implies strong duality. If Slater’s condition is satisfied, then <span class="math inline">\(x\)</span> is optimal if and only if there exist <span class="math inline">\(\lambda,\nu\)</span> that satisfy KKT conditions. Sometimes, by solving the KKT system, we can derive the closed-form solution of a optimization directly. Also, sometimes we will use the residual of the KKT system as the termination condition.</p>
<p>In general, <span class="math inline">\(f_i,h_i\)</span> may not be differentiable. There are also KKT conditions for them, which will include knowledge of subdifferential and will not be included here.</p>
</div>
</div>
<div id="appconvex-practice" class="section level2 hasAnchor" number="4.2">
<h2><span class="header-section-number">A.2</span> Practice<a href="appconvex.html#appconvex-practice" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="cvx-introduction" class="section level3 hasAnchor" number="4.2.1">
<h3><span class="header-section-number">A.2.1</span> CVX Introduction<a href="appconvex.html#cvx-introduction" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the last section, we have learned basic concepts and theorems in convex optimization. In this section, on the other hand, we will introduce you how to model basic convex optimization problems with CVX, an easy-to-use MATLAB package. To install CVX, please refer to this <a href="http://cvxr.com/cvx/doc/install.html">page</a>. Note that every time you what to use the CVX package, you should add it to your MATLAB path. For example, if I install CVX package in the parent directory of my current directory with default directory name <code>cvx</code>, the following line should be added before your CVX codes:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb6-1"><a href="appconvex.html#cb6-1" tabindex="-1"></a><span class="va">addpath</span>(<span class="va">genpath</span>(<span class="st">&quot;../cvx/&quot;</span>))<span class="op">;</span></span></code></pre></div>
<p>With CVX, it is incredibly easy for us to define and solve a convex optimization problem. You just need to:</p>
<ol style="list-style-type: decimal">
<li><p>define the variables.</p></li>
<li><p>define the objective function you want to minimize or maximize.</p></li>
<li><p>define the constraints.</p></li>
</ol>
<p>After running your codes, the optimal objective value is stored in the variable <code>cvx_optval</code>, and the problem status is stored in the variable <code>cvx_status</code> (when your problem is well-defined, this variable’s value will be <code>Solved</code>). The optimal solutions will be stored in the variables you define.</p>
<p>Throughout this section, we will study five types of convex optimization problems: linear programming (LP), quadratic programming (QP), (convex) quadratically constrained quadratic programming (QCQP), second-order cone programming (SOCP), and semidefinite programming (SDP). Given two types of optimization problems <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, we say <span class="math inline">\(A &lt; B\)</span> if <span class="math inline">\(A\)</span> can always be converted to <span class="math inline">\(B\)</span> while the inverse is not true. Under this notation, we have
<span class="math display">\[\begin{equation*}
   \text{LP} &lt; \text{QP} &lt; \text{QCQP} &lt; \text{SOCP} &lt; \text{SDP}
\end{equation*}\]</span></p>
</div>
<div id="linear-programming-lp" class="section level3 hasAnchor" number="4.2.2">
<h3><span class="header-section-number">A.2.2</span> Linear Programming (LP)<a href="appconvex.html#linear-programming-lp" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><strong>Definition.</strong> An LP has the following form:
<span class="math display" id="eq:app-lpdef">\[\begin{equation}
   \tag{A.1}
   \begin{aligned}
      \min_{x \in \mathbb{R}^n} &amp; \ c^T x \\
      \text{subject to } &amp; A x \le b  
   \end{aligned}
\end{equation}\]</span>
where <span class="math inline">\(x\)</span> is the variable, <span class="math inline">\(A \in \mathbb{R}^{m\times n}, b \in \mathbb{R}^m\)</span>, and <span class="math inline">\(c \in \mathbb{R}^n\)</span> are the parameters. Note that the constraint <span class="math inline">\(A x \le b\)</span> already incorporates linear equality constraints. To see this, consider the constraint <span class="math inline">\(A&#39; x = b&#39;\)</span>, we can reformulate it as <span class="math inline">\(A x \le b\)</span> by
<span class="math display">\[\begin{equation*}
   \begin{bmatrix}
      A&#39; \\ -A&#39;
   \end{bmatrix} x \le \begin{bmatrix}
      b&#39; \\ -b&#39;
   \end{bmatrix}
\end{equation*}\]</span></p>
<p><strong>Example.</strong> Consider the problem of minimizing a linear function <span class="math inline">\(c_1 x_1 + c_2 x_2\)</span> over a rectangle <span class="math inline">\([-l_1, l_1] \times [-l_2, l_2]\)</span>. We can convert it to the standard LP form in <a href="appconvex.html#eq:app-lpdef">(A.1)</a> by simply setting <span class="math inline">\(c\)</span> as <span class="math inline">\([c_1, \ c_2]^T\)</span> and the linear inequality constraint as
<span class="math display">\[\begin{equation*}
   \begin{bmatrix}
      1 &amp; 0 \\ -1 &amp; 0 \\ 0 &amp; 1 \\ 0 &amp; -1
   \end{bmatrix} \begin{bmatrix}
      x_1 \\ x_2
   \end{bmatrix} \le \begin{bmatrix}
      l_1 \\ l_1 \\ l_2 \\ l_2
   \end{bmatrix}
\end{equation*}\]</span></p>
<p>Corresponding CVX codes are shown below:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb7-1"><a href="appconvex.html#cb7-1" tabindex="-1"></a><span class="co">%% Define the LP example setting</span></span>
<span id="cb7-2"><a href="appconvex.html#cb7-2" tabindex="-1"></a><span class="va">c1</span> <span class="op">=</span> <span class="fl">2</span><span class="op">;</span></span>
<span id="cb7-3"><a href="appconvex.html#cb7-3" tabindex="-1"></a><span class="va">c2</span> <span class="op">=</span> <span class="op">-</span><span class="fl">5</span><span class="op">;</span></span>
<span id="cb7-4"><a href="appconvex.html#cb7-4" tabindex="-1"></a><span class="va">l1</span> <span class="op">=</span> <span class="fl">3</span><span class="op">;</span></span>
<span id="cb7-5"><a href="appconvex.html#cb7-5" tabindex="-1"></a><span class="va">l2</span> <span class="op">=</span> <span class="fl">7</span><span class="op">;</span></span>
<span id="cb7-6"><a href="appconvex.html#cb7-6" tabindex="-1"></a><span class="co">% parameters: c, A, b</span></span>
<span id="cb7-7"><a href="appconvex.html#cb7-7" tabindex="-1"></a><span class="va">c</span> <span class="op">=</span> [<span class="va">c1</span><span class="op">;</span> <span class="va">c2</span>]<span class="op">;</span></span>
<span id="cb7-8"><a href="appconvex.html#cb7-8" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span> [<span class="fl">1</span><span class="op">,</span> <span class="fl">0</span><span class="op">;</span> <span class="op">-</span><span class="fl">1</span><span class="op">,</span> <span class="fl">0</span><span class="op">;</span> <span class="fl">0</span><span class="op">,</span> <span class="fl">1</span><span class="op">;</span> <span class="fl">0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1</span>]<span class="op">;</span></span>
<span id="cb7-9"><a href="appconvex.html#cb7-9" tabindex="-1"></a><span class="va">b</span> <span class="op">=</span> [<span class="va">l1</span><span class="op">;</span> <span class="va">l1</span><span class="op">;</span> <span class="va">l2</span><span class="op">;</span> <span class="va">l2</span>]<span class="op">;</span></span>
<span id="cb7-10"><a href="appconvex.html#cb7-10" tabindex="-1"></a></span>
<span id="cb7-11"><a href="appconvex.html#cb7-11" tabindex="-1"></a><span class="co">%% solve LP</span></span>
<span id="cb7-12"><a href="appconvex.html#cb7-12" tabindex="-1"></a><span class="va">cvx_begin</span></span>
<span id="cb7-13"><a href="appconvex.html#cb7-13" tabindex="-1"></a>    <span class="va">variable</span> <span class="va">x</span>(<span class="fl">2</span>)<span class="op">;</span> <span class="co">% define variables [x1, x2]</span></span>
<span id="cb7-14"><a href="appconvex.html#cb7-14" tabindex="-1"></a>    <span class="va">minimize</span>(<span class="va">c</span><span class="op">&#39;</span> <span class="op">*</span> <span class="va">x</span>)<span class="op">;</span> <span class="co">% define the objective</span></span>
<span id="cb7-15"><a href="appconvex.html#cb7-15" tabindex="-1"></a>    <span class="va">subject</span> <span class="va">to</span></span>
<span id="cb7-16"><a href="appconvex.html#cb7-16" tabindex="-1"></a>        <span class="va">A</span> <span class="op">*</span> <span class="va">x</span> <span class="op">&lt;=</span> <span class="va">b</span><span class="op">;</span> <span class="co">% define the linear constraint</span></span>
<span id="cb7-17"><a href="appconvex.html#cb7-17" tabindex="-1"></a><span class="va">cvx_end</span></span></code></pre></div>
</div>
<div id="quadratic-programming-qp" class="section level3 hasAnchor" number="4.2.3">
<h3><span class="header-section-number">A.2.3</span> Quadratic Programming (QP)<a href="appconvex.html#quadratic-programming-qp" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><strong>Definition.</strong> A QP has the following form:
<span class="math display" id="eq:app-qpdef">\[\begin{align}
   \tag{A.2}
   \min_{x \in \mathbb{R}^n} \ &amp; \frac{1}{2} x^T P x + q^T x \\
   \text{subject to } &amp; Gx \le h \\
   &amp; Ax = b
\end{align}\]</span>
where <span class="math inline">\(P \in \mathcal{S}_+^n, q\in \mathbb{R}^n, G \in \mathbb{R}^{m \times n}, h\in \mathbb{R}^m, A \in \mathbb{R}^{p \times n}, b \in \mathbb{R}^p\)</span>. Here <span class="math inline">\(\mathcal{S}_+^n\)</span> denotes the set of positive semidefinite matrices of size <span class="math inline">\(n\times n\)</span>. Obviously, if we set <span class="math inline">\(P\)</span> as zero, QP will degenerate to LP.</p>
<p><strong>Example.</strong> Consider the problem of minimizing a quadratic function
<span class="math display">\[\begin{equation*}
   f(x_1, x_2) = p_1 x_1^2 + 2p_2 x_1 x_2 + p_3 x_2^2 + q_1 x_1 + q_2 x_2
\end{equation*}\]</span>
over a rectangle <span class="math inline">\([-l_1, l_1] \times [-l_2, l_2]\)</span>. Since <span class="math inline">\(P = 2 \begin{bmatrix}
   p_1 &amp; p_2 \\ p_2 &amp; p_3
\end{bmatrix} \succeq 0\)</span>, the following two conditions must hold:
<span class="math display">\[\begin{equation*}
   \begin{cases}
      p_1 \ge 0 \\
      p_1 p_3 - 4 p_2^2 \ge 0
   \end{cases}
\end{equation*}\]</span>
Same as in the LP example, <span class="math inline">\(G\)</span> and <span class="math inline">\(h\)</span> can be expressed as:
<span class="math display">\[\begin{equation*}
   \begin{bmatrix}
      1 &amp; 0 \\ -1 &amp; 0 \\ 0 &amp; 1 \\ 0 &amp; -1
   \end{bmatrix} \begin{bmatrix}
      x_1 \\ x_2
   \end{bmatrix} \le \begin{bmatrix}
      l_1 \\ l_1 \\ l_2 \\ l_2
   \end{bmatrix}
\end{equation*}\]</span></p>
<p>Corresponding CVX codes are shown below:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb8-1"><a href="appconvex.html#cb8-1" tabindex="-1"></a><span class="co">%% Define the QP example setting</span></span>
<span id="cb8-2"><a href="appconvex.html#cb8-2" tabindex="-1"></a><span class="va">p1</span> <span class="op">=</span> <span class="fl">2</span><span class="op">;</span></span>
<span id="cb8-3"><a href="appconvex.html#cb8-3" tabindex="-1"></a><span class="va">p2</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb8-4"><a href="appconvex.html#cb8-4" tabindex="-1"></a><span class="va">p3</span> <span class="op">=</span> <span class="fl">4</span><span class="op">;</span></span>
<span id="cb8-5"><a href="appconvex.html#cb8-5" tabindex="-1"></a><span class="va">q1</span> <span class="op">=</span> <span class="op">-</span><span class="fl">3</span><span class="op">;</span></span>
<span id="cb8-6"><a href="appconvex.html#cb8-6" tabindex="-1"></a><span class="va">q2</span> <span class="op">=</span> <span class="op">-</span><span class="fl">6.5</span><span class="op">;</span></span>
<span id="cb8-7"><a href="appconvex.html#cb8-7" tabindex="-1"></a><span class="va">l1</span> <span class="op">=</span> <span class="fl">2</span><span class="op">;</span></span>
<span id="cb8-8"><a href="appconvex.html#cb8-8" tabindex="-1"></a><span class="va">l2</span> <span class="op">=</span> <span class="fl">2.5</span><span class="op">;</span></span>
<span id="cb8-9"><a href="appconvex.html#cb8-9" tabindex="-1"></a><span class="co">% check if the generated P is positive semidefinite</span></span>
<span id="cb8-10"><a href="appconvex.html#cb8-10" tabindex="-1"></a><span class="va">tmp1</span> <span class="op">=</span> (<span class="va">p1</span> <span class="op">&gt;=</span> <span class="fl">0</span>)<span class="op">;</span></span>
<span id="cb8-11"><a href="appconvex.html#cb8-11" tabindex="-1"></a><span class="va">tmp2</span> <span class="op">=</span> (<span class="va">p1</span><span class="op">*</span><span class="va">p3</span> <span class="op">-</span> <span class="fl">4</span><span class="op">*</span><span class="va">p2</span><span class="op">^</span><span class="fl">2</span> <span class="op">&gt;=</span> <span class="fl">0</span>)<span class="op">;</span></span>
<span id="cb8-12"><a href="appconvex.html#cb8-12" tabindex="-1"></a><span class="kw">if</span> <span class="op">~</span>(<span class="va">tmp1</span> <span class="op">&amp;&amp;</span> <span class="va">tmp2</span>)</span>
<span id="cb8-13"><a href="appconvex.html#cb8-13" tabindex="-1"></a>    <span class="va">error</span>(<span class="st">&quot;P is not positve semidefinite!&quot;</span>)<span class="op">;</span></span>
<span id="cb8-14"><a href="appconvex.html#cb8-14" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-15"><a href="appconvex.html#cb8-15" tabindex="-1"></a><span class="co">% parameters: P, q, G, h</span></span>
<span id="cb8-16"><a href="appconvex.html#cb8-16" tabindex="-1"></a><span class="va">P</span> <span class="op">=</span> <span class="fl">2</span> <span class="op">*</span> [<span class="va">p1</span><span class="op">,</span> <span class="va">p2</span><span class="op">;</span> <span class="va">p2</span><span class="op">,</span> <span class="va">p3</span>]<span class="op">;</span></span>
<span id="cb8-17"><a href="appconvex.html#cb8-17" tabindex="-1"></a><span class="va">q</span> <span class="op">=</span> [<span class="va">q1</span><span class="op">;</span> <span class="va">q2</span>]<span class="op">;</span></span>
<span id="cb8-18"><a href="appconvex.html#cb8-18" tabindex="-1"></a><span class="va">G</span> <span class="op">=</span> [<span class="fl">1</span><span class="op">,</span> <span class="fl">0</span><span class="op">;</span> <span class="op">-</span><span class="fl">1</span><span class="op">,</span> <span class="fl">0</span><span class="op">;</span> <span class="fl">0</span><span class="op">,</span> <span class="fl">1</span><span class="op">;</span> <span class="fl">0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1</span>]<span class="op">;</span></span>
<span id="cb8-19"><a href="appconvex.html#cb8-19" tabindex="-1"></a><span class="va">h</span> <span class="op">=</span> [<span class="va">l1</span><span class="op">;</span> <span class="va">l1</span><span class="op">;</span> <span class="va">l2</span><span class="op">;</span> <span class="va">l2</span>]<span class="op">;</span></span>
<span id="cb8-20"><a href="appconvex.html#cb8-20" tabindex="-1"></a></span>
<span id="cb8-21"><a href="appconvex.html#cb8-21" tabindex="-1"></a><span class="co">%% Solve the QP problem</span></span>
<span id="cb8-22"><a href="appconvex.html#cb8-22" tabindex="-1"></a><span class="va">cvx_begin</span></span>
<span id="cb8-23"><a href="appconvex.html#cb8-23" tabindex="-1"></a>    <span class="va">variable</span> <span class="va">x</span>(<span class="fl">2</span>)<span class="op">;</span> <span class="co">% define variables [x1; x2]</span></span>
<span id="cb8-24"><a href="appconvex.html#cb8-24" tabindex="-1"></a>    <span class="co">% define the objective, where quad_form(x, P) = x&#39;*P*x</span></span>
<span id="cb8-25"><a href="appconvex.html#cb8-25" tabindex="-1"></a>    <span class="va">obj</span> <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="va">quad_form</span>(<span class="va">x</span><span class="op">,</span> <span class="va">P</span>) <span class="op">+</span> <span class="va">q</span><span class="op">&#39;</span> <span class="op">*</span> <span class="va">x</span><span class="op">;</span> </span>
<span id="cb8-26"><a href="appconvex.html#cb8-26" tabindex="-1"></a>    <span class="va">minimize</span>(<span class="va">obj</span>)<span class="op">;</span> </span>
<span id="cb8-27"><a href="appconvex.html#cb8-27" tabindex="-1"></a>    <span class="va">subject</span> <span class="va">to</span></span>
<span id="cb8-28"><a href="appconvex.html#cb8-28" tabindex="-1"></a>        <span class="va">G</span> <span class="op">*</span> <span class="va">x</span> <span class="op">&lt;=</span> <span class="va">h</span><span class="op">;</span> <span class="co">% define the linear constraint</span></span>
<span id="cb8-29"><a href="appconvex.html#cb8-29" tabindex="-1"></a><span class="va">cvx_end</span></span></code></pre></div>
</div>
<div id="quadratically-constrained-quadratic-programming-qcqp" class="section level3 hasAnchor" number="4.2.4">
<h3><span class="header-section-number">A.2.4</span> Quadratically Constrained Quadratic Programming (QCQP)<a href="appconvex.html#quadratically-constrained-quadratic-programming-qcqp" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><strong>Definition.</strong> An (convex) QCQP has the following form:
<span class="math display" id="eq:app-qcqpdef">\[\begin{align}
   \tag{A.3}
   \min_{x \in \mathbb{R}^n} \ &amp; \frac{1}{2} x^T P_0 x + q_0^T x \\
   \text{subject to } &amp; \frac{1}{2} x^T P_i x + q_i^T x + r_i \le 0, \ i = 1 \dots m \\
   &amp; Ax = b
\end{align}\]</span>
where <span class="math inline">\(P_i \in \mathcal{S}_+^n, i = 0 \dots m\)</span>, <span class="math inline">\(q_i \in \mathbb{R}^n, i = 0 \dots m\)</span>, <span class="math inline">\(A \in \mathbb{R}^{p \times n}\)</span>, and <span class="math inline">\(b \in \mathbb{R}^p\)</span>. Note that in other literature, you may find a more general form of QCQP: they don’t require <span class="math inline">\(P_i\)</span>’s to be positive semidefinite. Yet in this case, the problem is non-convex and beyond our scope.</p>
<p><strong>Example.</strong> We study the problem of getting the minimum distance between two ellipses. By convention, when the ellipses overlap, we set the minimum distance as <span class="math inline">\(0\)</span>. This problem can be exactly solved by (convex) QCQP.
Consider two ellipses of the following form:
<span class="math display">\[\begin{equation*}
   \begin{cases}
      \frac{1}{2} \begin{bmatrix} y_1 \\ z_1 \end{bmatrix}^T K_1 \begin{bmatrix} y_1 \\ z_1 \end{bmatrix}
      + k_1^T \begin{bmatrix} y_1 \\ z_1 \end{bmatrix} + c_1 \le 0 \\
      \frac{1}{2} \begin{bmatrix} y_2 \\ z_2 \end{bmatrix}^T K_2 \begin{bmatrix} y_2 \\ z_2 \end{bmatrix}
      + k_2^T \begin{bmatrix} y_2 \\ z_2 \end{bmatrix} + c_2 \le 0 \\
   \end{cases}
\end{equation*}\]</span>
where <span class="math inline">\([y_1, z_1]^T\)</span> and <span class="math inline">\([y_2, z_2]^T\)</span> are arbitrary points inside the two ellipses respectively. Also, two ensure the ellipses are well defined, we should enforce the following properties in <span class="math inline">\((K_i, k_i, c_i), i = 1, 2\)</span>: (1) <span class="math inline">\(K_i \succ 0\)</span>; (2) Let <span class="math inline">\(K_i =  L_i L_i^T\)</span> be the Cholesky decomposition of <span class="math inline">\(K_i\)</span>. Then, ellipse <span class="math inline">\(i\)</span> can be rewritten as:
<span class="math display">\[\begin{equation*}
   \frac{1}{2} \parallel L_i^T \begin{bmatrix} y_i \\ z_i \end{bmatrix} - L_i^{-1} k_i \parallel^2 \le
   \frac{1}{2} \parallel L_i^{-1} k_i \parallel^2 - c_i
\end{equation*}\]</span>
Thus,
<span class="math display">\[\begin{equation*}
   \frac{1}{2} \parallel L_i^{-1} k_i \parallel^2 - c_i &gt; 0
\end{equation*}\]</span>
With these two assumptions, we want to minimize:
<span class="math display">\[\begin{equation*}
   \frac{1}{2} (y_1 - y_2)^2 + (z_1 - z_2)^2
\end{equation*}\]</span></p>
<p>Now, we construct <span class="math inline">\(P, q, r\)</span>’s in QCQP with the above parameters. Define the variable <span class="math inline">\(x\)</span> as <span class="math inline">\([y_1, z_1, y_2, z_2]\)</span>.</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(P_0\)</span> can be obtained from:
<span class="math display">\[\begin{equation*}
   \frac{1}{2} (y_1 - y_2)^2 + (z_1 - z_2)^2 = \frac{1}{2} \begin{bmatrix}
  y_1 \\ z_1 \\ y_2 \\ z_2
   \end{bmatrix}^T \begin{bmatrix}
  1 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; -1 \\ -1 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; -1 &amp; 0 &amp; 1
   \end{bmatrix} \begin{bmatrix}
  y_1 \\ z_1 \\ y_2 \\ z_2
   \end{bmatrix}
\end{equation*}\]</span></p></li>
<li><p><span class="math inline">\(P_1, q_1, r_1\)</span> can be obtained from:
<span class="math display">\[\begin{equation*}
   \frac{1}{2} \begin{bmatrix} y_1 \\ z_1 \end{bmatrix}^T K_1 \begin{bmatrix} y_1 \\ z_1 \end{bmatrix}
  + k_1^T \begin{bmatrix} y_1 \\ z_1 \end{bmatrix} + c_1
   = \frac{1}{2} x^T \begin{bmatrix}
  K_1 &amp; O \\ O &amp; O
   \end{bmatrix} + \begin{bmatrix}
  k_1 \\ O
   \end{bmatrix}^T x + c_1 \le 0
\end{equation*}\]</span></p></li>
<li><p><span class="math inline">\(P_2, q_2, r_2\)</span> can be obtained from:
<span class="math display">\[\begin{equation*}
   \frac{1}{2} \begin{bmatrix} y_2 \\ z_2 \end{bmatrix}^T K_2 \begin{bmatrix} y_2 \\ z_2 \end{bmatrix}
  + k_2^T \begin{bmatrix} y_2 \\ z_2 \end{bmatrix} + c_2
   = \frac{1}{2} x^T \begin{bmatrix}
  O &amp; O \\ O &amp; K_2
   \end{bmatrix} + \begin{bmatrix}
  O \\ k_2
   \end{bmatrix}^T x + c_2 \le 0
\end{equation*}\]</span></p></li>
</ol>
<p>The corresponding codes are shown below. In this example, we test the minimum distance between a circle <span class="math inline">\(y_1^2 + z_1^2 \le 1\)</span> and another circle <span class="math inline">\((y_2 - 2)^2 + (z_2 - 2)^2 \le 1\)</span>. You can check whether the result from QCQP aligns with your manual calculation.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb9-1"><a href="appconvex.html#cb9-1" tabindex="-1"></a><span class="co">%% Define the QCQP example setting</span></span>
<span id="cb9-2"><a href="appconvex.html#cb9-2" tabindex="-1"></a><span class="va">K1</span> <span class="op">=</span> <span class="va">eye</span>(<span class="fl">2</span>)<span class="op">;</span></span>
<span id="cb9-3"><a href="appconvex.html#cb9-3" tabindex="-1"></a><span class="va">k1</span> <span class="op">=</span> <span class="va">zeros</span>(<span class="fl">2</span><span class="op">,</span> <span class="fl">1</span>)<span class="op">;</span></span>
<span id="cb9-4"><a href="appconvex.html#cb9-4" tabindex="-1"></a><span class="va">c1</span> <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb9-5"><a href="appconvex.html#cb9-5" tabindex="-1"></a><span class="va">K2</span> <span class="op">=</span> <span class="va">eye</span>(<span class="fl">2</span>)<span class="op">;</span></span>
<span id="cb9-6"><a href="appconvex.html#cb9-6" tabindex="-1"></a><span class="va">k2</span> <span class="op">=</span> [<span class="fl">2</span><span class="op">;</span> <span class="fl">2</span>]<span class="op">;</span></span>
<span id="cb9-7"><a href="appconvex.html#cb9-7" tabindex="-1"></a><span class="va">c2</span> <span class="op">=</span> <span class="fl">3.5</span><span class="op">;</span></span>
<span id="cb9-8"><a href="appconvex.html#cb9-8" tabindex="-1"></a><span class="kw">if</span> <span class="op">~</span>(<span class="va">if_ellipse</span>(<span class="va">K1</span><span class="op">,</span> <span class="va">k1</span><span class="op">,</span> <span class="va">c1</span>) <span class="op">&amp;&amp;</span> <span class="va">if_ellipse</span>(<span class="va">K2</span><span class="op">,</span> <span class="va">k2</span><span class="op">,</span> <span class="va">c2</span>))</span>
<span id="cb9-9"><a href="appconvex.html#cb9-9" tabindex="-1"></a>    <span class="va">error</span>(<span class="st">&quot;The example setting is not correct&quot;</span>)<span class="op">;</span></span>
<span id="cb9-10"><a href="appconvex.html#cb9-10" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb9-11"><a href="appconvex.html#cb9-11" tabindex="-1"></a><span class="co">% define parameters P0, P1, P2, q1, q2, r1, r2</span></span>
<span id="cb9-12"><a href="appconvex.html#cb9-12" tabindex="-1"></a><span class="va">P0</span> <span class="op">=</span> [<span class="fl">1</span><span class="op">,</span><span class="fl">0</span><span class="op">,-</span><span class="fl">1</span><span class="op">,</span><span class="fl">0</span><span class="op">;</span> <span class="fl">0</span><span class="op">,</span><span class="fl">1</span><span class="op">,</span><span class="fl">0</span><span class="op">,-</span><span class="fl">1</span><span class="op">;</span> <span class="op">-</span><span class="fl">1</span><span class="op">,</span><span class="fl">0</span><span class="op">,</span><span class="fl">1</span><span class="op">,</span><span class="fl">0</span><span class="op">;</span> <span class="fl">0</span><span class="op">,-</span><span class="fl">1</span><span class="op">,</span><span class="fl">0</span><span class="op">,</span><span class="fl">1</span>]<span class="op">;</span></span>
<span id="cb9-13"><a href="appconvex.html#cb9-13" tabindex="-1"></a><span class="va">P1</span> <span class="op">=</span> <span class="va">zeros</span>(<span class="fl">4</span><span class="op">,</span> <span class="fl">4</span>)<span class="op">;</span></span>
<span id="cb9-14"><a href="appconvex.html#cb9-14" tabindex="-1"></a><span class="va">P1</span>(<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">,</span> <span class="fl">1</span><span class="op">:</span><span class="fl">2</span>) <span class="op">=</span> <span class="va">K1</span><span class="op">;</span></span>
<span id="cb9-15"><a href="appconvex.html#cb9-15" tabindex="-1"></a><span class="va">P2</span> <span class="op">=</span> <span class="va">zeros</span>(<span class="fl">4</span><span class="op">,</span> <span class="fl">4</span>)<span class="op">;</span></span>
<span id="cb9-16"><a href="appconvex.html#cb9-16" tabindex="-1"></a><span class="va">P2</span>(<span class="fl">3</span><span class="op">:</span><span class="fl">4</span><span class="op">,</span> <span class="fl">3</span><span class="op">:</span><span class="fl">4</span>) <span class="op">=</span> <span class="va">K2</span><span class="op">;</span></span>
<span id="cb9-17"><a href="appconvex.html#cb9-17" tabindex="-1"></a><span class="va">q1</span> <span class="op">=</span> [<span class="va">k1</span><span class="op">;</span> <span class="va">zeros</span>(<span class="fl">2</span><span class="op">,</span> <span class="fl">1</span>)]<span class="op">;</span></span>
<span id="cb9-18"><a href="appconvex.html#cb9-18" tabindex="-1"></a><span class="va">q2</span> <span class="op">=</span> [<span class="va">zeros</span>(<span class="fl">2</span><span class="op">,</span> <span class="fl">1</span>)<span class="op">;</span> <span class="va">k2</span>]<span class="op">;</span></span>
<span id="cb9-19"><a href="appconvex.html#cb9-19" tabindex="-1"></a><span class="va">r1</span> <span class="op">=</span> <span class="va">c1</span><span class="op">;</span></span>
<span id="cb9-20"><a href="appconvex.html#cb9-20" tabindex="-1"></a><span class="va">r2</span> <span class="op">=</span> <span class="va">c2</span><span class="op">;</span></span>
<span id="cb9-21"><a href="appconvex.html#cb9-21" tabindex="-1"></a></span>
<span id="cb9-22"><a href="appconvex.html#cb9-22" tabindex="-1"></a><span class="co">%% Solve the QCQP problem</span></span>
<span id="cb9-23"><a href="appconvex.html#cb9-23" tabindex="-1"></a><span class="va">cvx_begin</span></span>
<span id="cb9-24"><a href="appconvex.html#cb9-24" tabindex="-1"></a>    <span class="va">variable</span> <span class="va">x</span>(<span class="fl">4</span>)<span class="op">;</span> <span class="co">% define variables [y1; z1; y2; z2]</span></span>
<span id="cb9-25"><a href="appconvex.html#cb9-25" tabindex="-1"></a>    <span class="co">% define the objective, where quad_form(x, P) = x&#39;*P*x</span></span>
<span id="cb9-26"><a href="appconvex.html#cb9-26" tabindex="-1"></a>    <span class="va">obj</span> <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="va">quad_form</span>(<span class="va">x</span><span class="op">,</span> <span class="va">P0</span>)<span class="op">;</span> </span>
<span id="cb9-27"><a href="appconvex.html#cb9-27" tabindex="-1"></a>    <span class="va">minimize</span>(<span class="va">obj</span>)<span class="op">;</span> </span>
<span id="cb9-28"><a href="appconvex.html#cb9-28" tabindex="-1"></a>    <span class="va">subject</span> <span class="va">to</span></span>
<span id="cb9-29"><a href="appconvex.html#cb9-29" tabindex="-1"></a>        <span class="fl">0.5</span> <span class="op">*</span> <span class="va">quad_form</span>(<span class="va">x</span><span class="op">,</span> <span class="va">P1</span>) <span class="op">+</span> <span class="va">q1</span><span class="op">&#39;</span> <span class="op">*</span> <span class="va">x</span> <span class="op">+</span> <span class="va">r1</span> <span class="op">&lt;=</span> <span class="fl">0</span><span class="op">;</span></span>
<span id="cb9-30"><a href="appconvex.html#cb9-30" tabindex="-1"></a>        <span class="fl">0.5</span> <span class="op">*</span> <span class="va">quad_form</span>(<span class="va">x</span><span class="op">,</span> <span class="va">P2</span>) <span class="op">+</span> <span class="va">q2</span><span class="op">&#39;</span> <span class="op">*</span> <span class="va">x</span> <span class="op">+</span> <span class="va">r2</span> <span class="op">&lt;=</span> <span class="fl">0</span><span class="op">;</span></span>
<span id="cb9-31"><a href="appconvex.html#cb9-31" tabindex="-1"></a><span class="va">cvx_end</span></span>
<span id="cb9-32"><a href="appconvex.html#cb9-32" tabindex="-1"></a></span>
<span id="cb9-33"><a href="appconvex.html#cb9-33" tabindex="-1"></a><span class="co">%% detect whether (K, k, c) generates a ellipse</span></span>
<span id="cb9-34"><a href="appconvex.html#cb9-34" tabindex="-1"></a><span class="kw">function</span> <span class="va">flag</span> <span class="op">=</span> <span class="va">if_ellipse</span>(<span class="va">K</span><span class="op">,</span> <span class="va">k</span><span class="op">,</span> <span class="va">c</span>)</span>
<span id="cb9-35"><a href="appconvex.html#cb9-35" tabindex="-1"></a>    <span class="va">L</span> <span class="op">=</span> <span class="va">chol</span>(<span class="va">K</span>)<span class="op">;</span></span>
<span id="cb9-36"><a href="appconvex.html#cb9-36" tabindex="-1"></a>    <span class="va">radius_square</span> <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="va">norm</span>(<span class="va">L</span> <span class="op">\</span> <span class="va">k</span>)<span class="op">^</span><span class="fl">2</span> <span class="op">-</span> <span class="va">c</span><span class="op">;</span> <span class="co">% L \ k = inv(L) * k</span></span>
<span id="cb9-37"><a href="appconvex.html#cb9-37" tabindex="-1"></a>    <span class="va">flag</span> <span class="op">=</span> (<span class="va">radius_square</span> <span class="op">&gt;</span> <span class="fl">0</span>)<span class="op">;</span></span>
<span id="cb9-38"><a href="appconvex.html#cb9-38" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<div id="second-order-cone-programming-socp" class="section level3 hasAnchor" number="4.2.5">
<h3><span class="header-section-number">A.2.5</span> Second-Order Cone Programming (SOCP)<a href="appconvex.html#second-order-cone-programming-socp" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><strong>Definition.</strong> An SOCP has the following form:
<span class="math display" id="eq:app-socpdef">\[\begin{align}
   \tag{A.4}
   \min_{x \in \mathbb{R}^n} \ &amp; f^T x \\
   \text{subject to } &amp; || A_i x + b_i ||_2 \le c_i^T x + d_i, \ i = 1 \dots m \\
   &amp; Fx = g
\end{align}\]</span>
where <span class="math inline">\(f \in \mathbb{R}^n, A_i \in \mathbb{R}^{n_i \times n}, b_i \in \mathbb{R}^{n_i}, c_i \in \mathbb{R}^n, d_i \in \mathbb{R}, F \in \mathbb{R}^{p \times n}\)</span>, and <span class="math inline">\(g \in \mathbb{R}^p\)</span>.</p>
<p><strong>Example.</strong> We consider the problem of stochastic linear programming:
<span class="math display">\[\begin{align}
   \min_x \ &amp; c^T x \\
   \text{subject to } &amp; \mathbb{P}(a_i^T x \le b_i) \ge p, \ i = 1 \dots m \\
   &amp; a_i \sim \mathcal{N}(\bar{a}_i, \Sigma_i), \ i = 1 \dots m
\end{align}\]</span>
Here <span class="math inline">\(p\)</span> should be more than <span class="math inline">\(0.5\)</span>. We show that this problem can be converted to a SOCP:</p>
<p>Since <span class="math inline">\(a_i \sim \mathcal{N}(\bar{a}_i, \Sigma_i)\)</span>, then <span class="math inline">\((a_i^T x - b_i) \sim \mathcal{N}(\bar{a}_i^T x - b_i, x^T \Sigma_i x)\)</span>. Standardize it:
<span class="math display">\[\begin{equation*}
   t := ||\Sigma_i^{\frac{1}{2}} x||_2^{-1} \left\{ (a_i^T x - b_i) - (\bar{a}_i^T x - b_i) \right\} \sim \mathcal{N}(0, 1)
\end{equation*}\]</span>
Then,
<span class="math display">\[\begin{align}
   \mathbb{P}(a_i^T x \le b_i) &amp; = \mathbb{P}(a_i^T x - b_i \le 0) \\
   &amp; = \mathbb{P}(t \le -||\Sigma_i^{\frac{1}{2}} x||_2^{-1}(\bar{a}_i^T x - b_i)) \\
   &amp; = \Phi(-||\Sigma_i^{\frac{1}{2}} x||_2^{-1}(\bar{a}_i^T x - b_i))
\end{align}\]</span>
Here <span class="math inline">\(\Phi(\cdot)\)</span> is the cumulative distribution function of the standard normal distribution:
<span class="math display">\[\begin{equation*}
   \Phi(\xi) = \int_{-\infty}^{\xi} e^{-\frac{1}{2} t^2} \ dt
\end{equation*}\]</span>
Thus,
<span class="math display">\[\begin{align}
   &amp; \mathbb{P}(a_i^T x \le b_i) \ge p \\
   \Longleftrightarrow &amp; \Phi(-||\Sigma_i^{\frac{1}{2}} x||_2^{-1}(\bar{a}_i^T x - b_i)) \ge p \\
   \Longleftrightarrow &amp; -||\Sigma_i^{\frac{1}{2}} x||_2^{-1}(\bar{a}_i^T x - b_i) \ge \Phi^{-1}(p) \\
   \Longleftrightarrow &amp; \Phi^{-1}(p) ||\Sigma_i^{\frac{1}{2}} x||_2 \le b_i - \bar{a}_i^T x
\end{align}\]</span>
which is exactly the same as inequality constraints in SOCP formulation. (You can see why we enforce <span class="math inline">\(p &gt; 0.5\)</span> here: otherwise <span class="math inline">\(\Phi^{-1}(p)\)</span> will be negative and the constraint with not be an second-order cone.)</p>
<p>In the following code example, we set up four inequality constraints and let <span class="math inline">\(\bar{a}_i^T x \le b_i, \ i = 1 \dots 4\)</span> form an square located at the origin of size <span class="math inline">\(2\)</span>. Then, for convenience, we set <span class="math inline">\(\Sigma_i \equiv \sigma^2 I\)</span>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb10-1"><a href="appconvex.html#cb10-1" tabindex="-1"></a><span class="co">%% Define the SOCP example setting</span></span>
<span id="cb10-2"><a href="appconvex.html#cb10-2" tabindex="-1"></a><span class="va">bar_a1</span> <span class="op">=</span> [<span class="fl">1</span><span class="op">;</span> <span class="fl">0</span>]<span class="op">;</span></span>
<span id="cb10-3"><a href="appconvex.html#cb10-3" tabindex="-1"></a><span class="va">b1</span> <span class="op">=</span> <span class="fl">1</span><span class="op">;</span></span>
<span id="cb10-4"><a href="appconvex.html#cb10-4" tabindex="-1"></a><span class="va">bar_a2</span> <span class="op">=</span> [<span class="fl">0</span><span class="op">;</span> <span class="fl">1</span>]<span class="op">;</span></span>
<span id="cb10-5"><a href="appconvex.html#cb10-5" tabindex="-1"></a><span class="va">b2</span> <span class="op">=</span> <span class="fl">1</span><span class="op">;</span></span>
<span id="cb10-6"><a href="appconvex.html#cb10-6" tabindex="-1"></a><span class="va">bar_a3</span> <span class="op">=</span> [<span class="op">-</span><span class="fl">1</span><span class="op">;</span> <span class="fl">0</span>]<span class="op">;</span></span>
<span id="cb10-7"><a href="appconvex.html#cb10-7" tabindex="-1"></a><span class="va">b3</span> <span class="op">=</span> <span class="fl">1</span><span class="op">;</span></span>
<span id="cb10-8"><a href="appconvex.html#cb10-8" tabindex="-1"></a><span class="va">bar_a4</span> <span class="op">=</span> [<span class="fl">0</span><span class="op">;</span> <span class="op">-</span><span class="fl">1</span>]<span class="op">;</span></span>
<span id="cb10-9"><a href="appconvex.html#cb10-9" tabindex="-1"></a><span class="va">b4</span> <span class="op">=</span> <span class="fl">1</span><span class="op">;</span></span>
<span id="cb10-10"><a href="appconvex.html#cb10-10" tabindex="-1"></a><span class="va">sigma</span> <span class="op">=</span> <span class="fl">0.1</span><span class="op">;</span> </span>
<span id="cb10-11"><a href="appconvex.html#cb10-11" tabindex="-1"></a><span class="va">c</span> <span class="op">=</span> [<span class="fl">2</span><span class="op">;</span> <span class="fl">3</span>]<span class="op">;</span></span>
<span id="cb10-12"><a href="appconvex.html#cb10-12" tabindex="-1"></a><span class="va">p</span> <span class="op">=</span> <span class="fl">0.9</span><span class="op">;</span> <span class="co">% p should be more than 0.5</span></span>
<span id="cb10-13"><a href="appconvex.html#cb10-13" tabindex="-1"></a><span class="va">Phi_inv</span> <span class="op">=</span> <span class="va">norminv</span>(<span class="va">p</span>)<span class="op">;</span> <span class="co">% get Phi^{-1}(p)</span></span>
<span id="cb10-14"><a href="appconvex.html#cb10-14" tabindex="-1"></a></span>
<span id="cb10-15"><a href="appconvex.html#cb10-15" tabindex="-1"></a><span class="co">%% Solve the SOCP problem</span></span>
<span id="cb10-16"><a href="appconvex.html#cb10-16" tabindex="-1"></a><span class="va">cvx_begin</span></span>
<span id="cb10-17"><a href="appconvex.html#cb10-17" tabindex="-1"></a>    <span class="va">variable</span> <span class="va">x</span>(<span class="fl">2</span>)<span class="op">;</span> <span class="co">% define variables [x1; x2]</span></span>
<span id="cb10-18"><a href="appconvex.html#cb10-18" tabindex="-1"></a>    <span class="va">minimize</span>(<span class="va">c</span><span class="op">&#39;</span> <span class="op">*</span> <span class="va">x</span>)<span class="op">;</span> </span>
<span id="cb10-19"><a href="appconvex.html#cb10-19" tabindex="-1"></a>    <span class="va">subject</span> <span class="va">to</span></span>
<span id="cb10-20"><a href="appconvex.html#cb10-20" tabindex="-1"></a>        <span class="va">sigma</span><span class="op">*</span><span class="va">Phi_inv</span> <span class="op">*</span> <span class="va">norm</span>(<span class="va">x</span>) <span class="op">&lt;=</span> <span class="va">b1</span> <span class="op">-</span> <span class="va">bar_a1</span><span class="op">&#39;</span> <span class="op">*</span> <span class="va">x</span><span class="op">;</span></span>
<span id="cb10-21"><a href="appconvex.html#cb10-21" tabindex="-1"></a>        <span class="va">sigma</span><span class="op">*</span><span class="va">Phi_inv</span> <span class="op">*</span> <span class="va">norm</span>(<span class="va">x</span>) <span class="op">&lt;=</span> <span class="va">b2</span> <span class="op">-</span> <span class="va">bar_a2</span><span class="op">&#39;</span> <span class="op">*</span> <span class="va">x</span><span class="op">;</span></span>
<span id="cb10-22"><a href="appconvex.html#cb10-22" tabindex="-1"></a>        <span class="va">sigma</span><span class="op">*</span><span class="va">Phi_inv</span> <span class="op">*</span> <span class="va">norm</span>(<span class="va">x</span>) <span class="op">&lt;=</span> <span class="va">b3</span> <span class="op">-</span> <span class="va">bar_a3</span><span class="op">&#39;</span> <span class="op">*</span> <span class="va">x</span><span class="op">;</span></span>
<span id="cb10-23"><a href="appconvex.html#cb10-23" tabindex="-1"></a>        <span class="va">sigma</span><span class="op">*</span><span class="va">Phi_inv</span> <span class="op">*</span> <span class="va">norm</span>(<span class="va">x</span>) <span class="op">&lt;=</span> <span class="va">b4</span> <span class="op">-</span> <span class="va">bar_a4</span><span class="op">&#39;</span> <span class="op">*</span> <span class="va">x</span><span class="op">;</span></span>
<span id="cb10-24"><a href="appconvex.html#cb10-24" tabindex="-1"></a><span class="va">cvx_end</span></span></code></pre></div>
</div>
<div id="semidefinite-programming-sdp" class="section level3 hasAnchor" number="4.2.6">
<h3><span class="header-section-number">A.2.6</span> Semidefinite Programming (SDP)<a href="appconvex.html#semidefinite-programming-sdp" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><strong>Definition.</strong> An SDP has the following form:
<span class="math display" id="eq:app-sdpdef">\[\begin{align}
   \tag{A.5}
   \min_{X_i, x_i} \ &amp; \sum_{i=1}^{n_s} C_i \cdot X_i + \sum_{i=1}^{n_u} c_i \cdot x_i \\
   \text{subject to } &amp; \sum_{i=1}^{n_s} A_{i,j} \cdot X_i + \sum_{i=1}^{n_u} a_{i,j} \cdot x_i = b_j, \quad j = 1 \dots m \\
   &amp; X_i \in \mathcal{S}_+^{D_i}, \quad i = 1 \dots n_s \\
   &amp; x_i \in \mathbb{R}^{d_i}, \quad i = 1 \dots n_u  
\end{align}\]</span>
where <span class="math inline">\(C_i, A_{i, j} \in \mathbb{R}^{D_i \times D_i}\)</span>, <span class="math inline">\(c_i, a_{i, j} \in \mathbb{R}^{d_i}\)</span>, and <span class="math inline">\(\cdot\)</span> means element-wise product. For two square matrices <span class="math inline">\(A, B\)</span>, the dot product <span class="math inline">\(A \cdot B\)</span> is equal to <span class="math inline">\(\text{tr}(A B)\)</span>; for two vectors <span class="math inline">\(a, b\)</span>, the dot product <span class="math inline">\(a \cdot b\)</span> is the same as inner product <span class="math inline">\(a^T b\)</span>.</p>
<p>Note that actually there are many “standard” forms of SDP. For example, in the convex optimization theory part, you may find an SDP that looks like:
<span class="math display">\[\begin{align}
   \min_X \ &amp; C \cdot X \\
   \text{subject to } &amp; A \cdot X = b \\
   &amp; X \succeq 0
\end{align}\]</span>
It is convenient for us to analyze the theoretical properties of SDP with this form. Also, in SDP solvers’ User Guide, you may see more complex SDP forms which involve more general convex cones. For example, see <a href="https://docs.mosek.com/10.0/toolbox/tutorial-sdo-shared.html#doc-tutorial-sdo">MOSEK’s MATLAB API docs</a>. Here we turn to use the form of <a href="appconvex.html#eq:app-sdpdef">(A.5)</a> for two reasons: (1) it is general enough: our SDP example below can be converted to this form (also, SDPs from sum-of-squares programming in this book are exactly of the form <a href="appconvex.html#eq:app-sdpdef">(A.5)</a>); (2) it is more readable than more complex forms.</p>
<p><strong>Example.</strong> We consider the problem of finding the minimum eigenvalue for a positive semidefinite matrix <span class="math inline">\(S\)</span>. We will show that this problem can be converted to <a href="appconvex.html#eq:app-sdpdef">(A.5)</a>. Since <span class="math inline">\(S\)</span> is positive semidefinite, the finding procedure can be cast as
<span class="math display">\[\begin{align}
    \max_\lambda &amp; \ \lambda \\
    \text{subject to } &amp; S - \lambda I \succeq 0
\end{align}\]</span>
Now define an auxiliary matrix <span class="math inline">\(X := S - \lambda I\)</span>. We have
<span class="math display">\[\begin{align}
    \min_{\lambda, X} &amp; \ -\lambda \\
   \text{subject to } &amp;  X + \lambda I = S \\
   &amp; X \succeq 0
\end{align}\]</span>
It is obvious that the linear matrix equality constraint <span class="math inline">\(X + \lambda I = S\)</span> can be divided into several linear scalar equality constraints in <a href="appconvex.html#eq:app-sdpdef">(A.5)</a>. For example, we consider <span class="math inline">\(S \in \mathbb{S}_+^3\)</span>. Thereby <span class="math inline">\(X + \lambda I = S\)</span> will lead to <span class="math inline">\(6\)</span> linear equality constraints (We don’t consider <span class="math inline">\(X\)</span> is a symmetric matrix here, since most solvers will implicitly consider this. Thus, only the upper-triangular part of <span class="math inline">\(X\)</span> and <span class="math inline">\(S\)</span> are actually used in the equality construction.):
<span class="math display">\[\begin{align}
   &amp;  \begin{bmatrix}
      1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0
   \end{bmatrix} \cdot X  + \lambda = S[0, 0],  
    \begin{bmatrix}
      0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0
   \end{bmatrix} \cdot X  = S[0, 1],
    \begin{bmatrix}
      0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0
   \end{bmatrix} \cdot X  = S[0, 2] \\
   &amp;  \begin{bmatrix}
      0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0
   \end{bmatrix} \cdot X  + \lambda = S[1, 1],
    \begin{bmatrix}
      0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 0
   \end{bmatrix} \cdot X  = S[1, 2],
    \begin{bmatrix}
      0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1
   \end{bmatrix} \cdot X  + \lambda = S[2, 2]
\end{align}\]</span>
Seems tedious? Fortunately, CVX provides a high-level API to handle these linear equality constraints: you just need to write down</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb11-1"><a href="appconvex.html#cb11-1" tabindex="-1"></a><span class="va">X</span> <span class="op">+</span> <span class="va">lam</span> <span class="op">*</span> <span class="va">eye</span>(<span class="fl">3</span>) <span class="op">==</span> <span class="va">S</span><span class="op">;</span> <span class="co">% linear equality constraints: X + lam *I = S</span></span></code></pre></div>
<p>CVX will autometically convert this high-level constraint to <a href="appconvex.html#eq:app-sdpdef">(A.5)</a> and pass them to the underlying solver.</p>
<p>To generate a ramdom <span class="math inline">\(S \in \mathcal{S}_+^3\)</span>, you just need to assign three nonnegative eigenvalues to the program. After that, an random <span class="math inline">\(S\)</span> will be generated by <span class="math inline">\(S = Q \ \text{diag}(\lambda_1, \lambda_2, \lambda_3) \ Q^T\)</span>, where <span class="math inline">\(Q\)</span> is random orthonormal matrix.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb12-1"><a href="appconvex.html#cb12-1" tabindex="-1"></a><span class="co">%% Define the SDP example setting</span></span>
<span id="cb12-2"><a href="appconvex.html#cb12-2" tabindex="-1"></a><span class="va">lam_list</span> <span class="op">=</span> [<span class="fl">0.7</span><span class="op">;</span> <span class="fl">2.4</span><span class="op">;</span> <span class="fl">3.7</span>]<span class="op">;</span></span>
<span id="cb12-3"><a href="appconvex.html#cb12-3" tabindex="-1"></a><span class="va">S</span> <span class="op">=</span> <span class="va">generate_random_PD_matrix</span>(<span class="va">lam_list</span>)<span class="op">;</span> <span class="co">% get a PD matrix S</span></span>
<span id="cb12-4"><a href="appconvex.html#cb12-4" tabindex="-1"></a></span>
<span id="cb12-5"><a href="appconvex.html#cb12-5" tabindex="-1"></a><span class="co">%% Solve the SDP problem</span></span>
<span id="cb12-6"><a href="appconvex.html#cb12-6" tabindex="-1"></a><span class="va">cvx_begin</span></span>
<span id="cb12-7"><a href="appconvex.html#cb12-7" tabindex="-1"></a>    <span class="va">variable</span> <span class="va">X</span>(<span class="fl">3</span><span class="op">,</span> <span class="fl">3</span>) <span class="va">symmetric</span><span class="op">;</span></span>
<span id="cb12-8"><a href="appconvex.html#cb12-8" tabindex="-1"></a>    <span class="va">variable</span> <span class="va">lam</span><span class="op">;</span> </span>
<span id="cb12-9"><a href="appconvex.html#cb12-9" tabindex="-1"></a>    <span class="va">maximize</span>(<span class="va">lam</span>)<span class="op">;</span> </span>
<span id="cb12-10"><a href="appconvex.html#cb12-10" tabindex="-1"></a>    <span class="va">subject</span> <span class="va">to</span></span>
<span id="cb12-11"><a href="appconvex.html#cb12-11" tabindex="-1"></a>        <span class="co">% here &quot;==&quot; should be read as &quot;is in&quot;</span></span>
<span id="cb12-12"><a href="appconvex.html#cb12-12" tabindex="-1"></a>        <span class="va">X</span> <span class="op">==</span> <span class="va">semidefinite</span>(<span class="fl">3</span>)<span class="op">;</span> </span>
<span id="cb12-13"><a href="appconvex.html#cb12-13" tabindex="-1"></a>        <span class="va">X</span> <span class="op">+</span> <span class="va">lam</span> <span class="op">*</span> <span class="va">eye</span>(<span class="fl">3</span>) <span class="op">==</span> <span class="va">S</span><span class="op">;</span></span>
<span id="cb12-14"><a href="appconvex.html#cb12-14" tabindex="-1"></a><span class="va">cvx_end</span></span>
<span id="cb12-15"><a href="appconvex.html#cb12-15" tabindex="-1"></a></span>
<span id="cb12-16"><a href="appconvex.html#cb12-16" tabindex="-1"></a><span class="co">% this function help to generate PD matrix of size 3*3 </span></span>
<span id="cb12-17"><a href="appconvex.html#cb12-17" tabindex="-1"></a><span class="co">% if you provide the eigenvalues [lam_1, lam_2, lam_3]</span></span>
<span id="cb12-18"><a href="appconvex.html#cb12-18" tabindex="-1"></a><span class="kw">function</span> <span class="va">S</span> <span class="op">=</span> <span class="va">generate_random_PD_matrix</span>(<span class="va">lam_list</span>)</span>
<span id="cb12-19"><a href="appconvex.html#cb12-19" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">~</span><span class="va">all</span>(<span class="va">lam_list</span> <span class="op">&gt;=</span> <span class="fl">0</span>) <span class="co">% all eigenvalues &gt;= 0</span></span>
<span id="cb12-20"><a href="appconvex.html#cb12-20" tabindex="-1"></a>        <span class="va">error</span>(<span class="st">&quot;All eigenvalues must be nonnegative.&quot;</span>)<span class="op">;</span></span>
<span id="cb12-21"><a href="appconvex.html#cb12-21" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb12-22"><a href="appconvex.html#cb12-22" tabindex="-1"></a>    <span class="va">D</span> <span class="op">=</span> <span class="va">diag</span>(<span class="va">lam_list</span>)<span class="op">;</span></span>
<span id="cb12-23"><a href="appconvex.html#cb12-23" tabindex="-1"></a>    <span class="co">% use QR factorization to generate a random orthonormal matrix Q</span></span>
<span id="cb12-24"><a href="appconvex.html#cb12-24" tabindex="-1"></a>    [<span class="va">Q</span><span class="op">,</span> <span class="op">~</span>] <span class="op">=</span> <span class="va">qr</span>(<span class="va">rand</span>(<span class="fl">3</span><span class="op">,</span> <span class="fl">3</span>))<span class="op">;</span></span>
<span id="cb12-25"><a href="appconvex.html#cb12-25" tabindex="-1"></a>    <span class="va">S</span> <span class="op">=</span>  <span class="va">Q</span> <span class="op">*</span> <span class="va">D</span> <span class="op">*</span> <span class="va">Q</span><span class="op">&#39;;</span></span>
<span id="cb12-26"><a href="appconvex.html#cb12-26" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<div id="cvxpy-introduction-and-examples" class="section level3 hasAnchor" number="4.2.7">
<h3><span class="header-section-number">A.2.7</span> CVXPY Introduction and Examples<a href="appconvex.html#cvxpy-introduction-and-examples" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Apart from CVX MATLAB, we also have a Python package called CVXPY, which functions almost the same as CVX MATLAB. To define and solve a convex optimization problem CVXPY, basically, there are three steps (apart from importing necessary packages):</p>
<ul>
<li><p>Step 1: Define parameters and variables in a certain type of convex problem. Here variables are what you are trying to optimize or “learn”. Parameters are the “coefficients” of variables in the objective and constraints.</p></li>
<li><p>Step 2: Define the objective function and constraints.</p></li>
<li><p>Step 3: Solve the problem and get the results.</p></li>
</ul>
<p>Here we provide the CVXPY codes for the above five convex optimization examples.</p>
<div id="lp" class="section level4 hasAnchor" number="4.2.7.1">
<h4><span class="header-section-number">A.2.7.1</span> LP<a href="appconvex.html#lp" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="appconvex.html#cb13-1" tabindex="-1"></a><span class="im">import</span> cvxpy <span class="im">as</span> cp</span>
<span id="cb13-2"><a href="appconvex.html#cb13-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-3"><a href="appconvex.html#cb13-3" tabindex="-1"></a></span>
<span id="cb13-4"><a href="appconvex.html#cb13-4" tabindex="-1"></a><span class="co">## Define the LP example setting</span></span>
<span id="cb13-5"><a href="appconvex.html#cb13-5" tabindex="-1"></a>c1 <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb13-6"><a href="appconvex.html#cb13-6" tabindex="-1"></a>c2 <span class="op">=</span> <span class="op">-</span><span class="dv">5</span></span>
<span id="cb13-7"><a href="appconvex.html#cb13-7" tabindex="-1"></a>l1 <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb13-8"><a href="appconvex.html#cb13-8" tabindex="-1"></a>l2 <span class="op">=</span> <span class="dv">7</span></span>
<span id="cb13-9"><a href="appconvex.html#cb13-9" tabindex="-1"></a></span>
<span id="cb13-10"><a href="appconvex.html#cb13-10" tabindex="-1"></a><span class="co">## Step 1: define variables and parameters</span></span>
<span id="cb13-11"><a href="appconvex.html#cb13-11" tabindex="-1"></a>x <span class="op">=</span> cp.Variable(<span class="dv">2</span>) <span class="co"># variable: x = [x1, x2]^T</span></span>
<span id="cb13-12"><a href="appconvex.html#cb13-12" tabindex="-1"></a><span class="co"># parameters: c, A, b</span></span>
<span id="cb13-13"><a href="appconvex.html#cb13-13" tabindex="-1"></a>c <span class="op">=</span> np.array([c1, c2]) </span>
<span id="cb13-14"><a href="appconvex.html#cb13-14" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb13-15"><a href="appconvex.html#cb13-15" tabindex="-1"></a>b <span class="op">=</span> np.array([l1, l1, l2, l2])</span>
<span id="cb13-16"><a href="appconvex.html#cb13-16" tabindex="-1"></a></span>
<span id="cb13-17"><a href="appconvex.html#cb13-17" tabindex="-1"></a><span class="co">## Step 2: define objective and constraints</span></span>
<span id="cb13-18"><a href="appconvex.html#cb13-18" tabindex="-1"></a>obj <span class="op">=</span> cp.Minimize(c.T <span class="op">@</span> x)</span>
<span id="cb13-19"><a href="appconvex.html#cb13-19" tabindex="-1"></a>constraints <span class="op">=</span> [A <span class="op">@</span> x <span class="op">&lt;=</span> b]</span>
<span id="cb13-20"><a href="appconvex.html#cb13-20" tabindex="-1"></a>prob <span class="op">=</span> cp.Problem(obj, constraints) <span class="co"># form the problem</span></span>
<span id="cb13-21"><a href="appconvex.html#cb13-21" tabindex="-1"></a></span>
<span id="cb13-22"><a href="appconvex.html#cb13-22" tabindex="-1"></a><span class="co">## Step 3: solve problem and get results</span></span>
<span id="cb13-23"><a href="appconvex.html#cb13-23" tabindex="-1"></a>prob.solve()  </span>
<span id="cb13-24"><a href="appconvex.html#cb13-24" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;status: &quot;</span>, prob.status) <span class="co"># check whether the status is &quot;optimal&quot;</span></span>
<span id="cb13-25"><a href="appconvex.html#cb13-25" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;optimal value: &quot;</span>, prob.value) <span class="co"># optimal objective</span></span>
<span id="cb13-26"><a href="appconvex.html#cb13-26" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;optimal solution: &quot;</span>, x.value) <span class="co"># optimal x</span></span></code></pre></div>
</div>
<div id="qp" class="section level4 hasAnchor" number="4.2.7.2">
<h4><span class="header-section-number">A.2.7.2</span> QP<a href="appconvex.html#qp" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="appconvex.html#cb14-1" tabindex="-1"></a><span class="im">import</span> cvxpy <span class="im">as</span> cp</span>
<span id="cb14-2"><a href="appconvex.html#cb14-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-3"><a href="appconvex.html#cb14-3" tabindex="-1"></a></span>
<span id="cb14-4"><a href="appconvex.html#cb14-4" tabindex="-1"></a><span class="co">## Define the LP example setting</span></span>
<span id="cb14-5"><a href="appconvex.html#cb14-5" tabindex="-1"></a>p1 <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb14-6"><a href="appconvex.html#cb14-6" tabindex="-1"></a>p2 <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb14-7"><a href="appconvex.html#cb14-7" tabindex="-1"></a>p3 <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb14-8"><a href="appconvex.html#cb14-8" tabindex="-1"></a>q1 <span class="op">=</span> <span class="op">-</span><span class="dv">3</span></span>
<span id="cb14-9"><a href="appconvex.html#cb14-9" tabindex="-1"></a>q2 <span class="op">=</span> <span class="op">-</span><span class="fl">6.5</span></span>
<span id="cb14-10"><a href="appconvex.html#cb14-10" tabindex="-1"></a>l1 <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb14-11"><a href="appconvex.html#cb14-11" tabindex="-1"></a>l2 <span class="op">=</span> <span class="fl">2.5</span></span>
<span id="cb14-12"><a href="appconvex.html#cb14-12" tabindex="-1"></a><span class="co"># check if the generated P is positive semidefinite</span></span>
<span id="cb14-13"><a href="appconvex.html#cb14-13" tabindex="-1"></a>tmp1 <span class="op">=</span> (p1 <span class="op">&gt;=</span> <span class="dv">0</span>)</span>
<span id="cb14-14"><a href="appconvex.html#cb14-14" tabindex="-1"></a>tmp2 <span class="op">=</span> (p1<span class="op">*</span>p3 <span class="op">-</span> <span class="dv">4</span><span class="op">*</span>p2<span class="op">**</span><span class="dv">2</span> <span class="op">&gt;=</span> <span class="dv">0</span>)</span>
<span id="cb14-15"><a href="appconvex.html#cb14-15" tabindex="-1"></a><span class="cf">assert</span>(tmp1 <span class="kw">and</span> tmp2, <span class="st">&quot;P is not positve semidefinite!&quot;</span>)</span>
<span id="cb14-16"><a href="appconvex.html#cb14-16" tabindex="-1"></a></span>
<span id="cb14-17"><a href="appconvex.html#cb14-17" tabindex="-1"></a><span class="co">## Step 1: define variables and parameters</span></span>
<span id="cb14-18"><a href="appconvex.html#cb14-18" tabindex="-1"></a>x <span class="op">=</span> cp.Variable(<span class="dv">2</span>) <span class="co"># variable: x = [x1, x2]^T</span></span>
<span id="cb14-19"><a href="appconvex.html#cb14-19" tabindex="-1"></a><span class="co"># parameters: P, q, G, h</span></span>
<span id="cb14-20"><a href="appconvex.html#cb14-20" tabindex="-1"></a>P <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>np.array([[p1, p2], [p2, p3]])</span>
<span id="cb14-21"><a href="appconvex.html#cb14-21" tabindex="-1"></a>q <span class="op">=</span> np.array([q1, q2]) </span>
<span id="cb14-22"><a href="appconvex.html#cb14-22" tabindex="-1"></a>G <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb14-23"><a href="appconvex.html#cb14-23" tabindex="-1"></a>h <span class="op">=</span> np.array([l1, l1, l2, l2])</span>
<span id="cb14-24"><a href="appconvex.html#cb14-24" tabindex="-1"></a></span>
<span id="cb14-25"><a href="appconvex.html#cb14-25" tabindex="-1"></a><span class="co">## Step 2: define the objective and constraints</span></span>
<span id="cb14-26"><a href="appconvex.html#cb14-26" tabindex="-1"></a>fx <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> cp.quad_form(x, P) <span class="op">+</span> q.T <span class="op">@</span> x</span>
<span id="cb14-27"><a href="appconvex.html#cb14-27" tabindex="-1"></a>obj <span class="op">=</span> cp.Minimize(fx)</span>
<span id="cb14-28"><a href="appconvex.html#cb14-28" tabindex="-1"></a>constraints <span class="op">=</span> [G <span class="op">@</span> x <span class="op">&lt;=</span> h]</span>
<span id="cb14-29"><a href="appconvex.html#cb14-29" tabindex="-1"></a>prob <span class="op">=</span> cp.Problem(obj, constraints) <span class="co"># form the problem</span></span>
<span id="cb14-30"><a href="appconvex.html#cb14-30" tabindex="-1"></a></span>
<span id="cb14-31"><a href="appconvex.html#cb14-31" tabindex="-1"></a><span class="co">## Step 3: solve the problem and get results</span></span>
<span id="cb14-32"><a href="appconvex.html#cb14-32" tabindex="-1"></a>prob.solve()  </span>
<span id="cb14-33"><a href="appconvex.html#cb14-33" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;status: &quot;</span>, prob.status) <span class="co"># check whether the status is &quot;optimal&quot;</span></span>
<span id="cb14-34"><a href="appconvex.html#cb14-34" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;optimal value: &quot;</span>, prob.value) <span class="co"># optimal objective</span></span>
<span id="cb14-35"><a href="appconvex.html#cb14-35" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;optimal solution: &quot;</span>, x.value) <span class="co"># optimal x</span></span></code></pre></div>
</div>
<div id="qcqp" class="section level4 hasAnchor" number="4.2.7.3">
<h4><span class="header-section-number">A.2.7.3</span> QCQP<a href="appconvex.html#qcqp" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="appconvex.html#cb15-1" tabindex="-1"></a><span class="im">import</span> cvxpy <span class="im">as</span> cp</span>
<span id="cb15-2"><a href="appconvex.html#cb15-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-3"><a href="appconvex.html#cb15-3" tabindex="-1"></a><span class="im">from</span> numpy.linalg <span class="im">import</span> cholesky, inv, norm</span>
<span id="cb15-4"><a href="appconvex.html#cb15-4" tabindex="-1"></a></span>
<span id="cb15-5"><a href="appconvex.html#cb15-5" tabindex="-1"></a><span class="co">## Define the QCQP example setting</span></span>
<span id="cb15-6"><a href="appconvex.html#cb15-6" tabindex="-1"></a><span class="kw">def</span> if_ellipse(K, k, c):</span>
<span id="cb15-7"><a href="appconvex.html#cb15-7" tabindex="-1"></a>    <span class="co"># examine whether 0.5*x^T K x + k^T x + c &lt;= 0 is a ellipse</span></span>
<span id="cb15-8"><a href="appconvex.html#cb15-8" tabindex="-1"></a>    <span class="co"># if K is not positive semidefinite, Cholesky will raise an error</span></span>
<span id="cb15-9"><a href="appconvex.html#cb15-9" tabindex="-1"></a>    L <span class="op">=</span> cholesky(K) </span>
<span id="cb15-10"><a href="appconvex.html#cb15-10" tabindex="-1"></a>    radius_square <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> norm(inv(L) <span class="op">@</span> k)<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> c</span>
<span id="cb15-11"><a href="appconvex.html#cb15-11" tabindex="-1"></a>    <span class="cf">return</span> radius_square <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb15-12"><a href="appconvex.html#cb15-12" tabindex="-1"></a>K1 <span class="op">=</span> np.eye(<span class="dv">2</span>)</span>
<span id="cb15-13"><a href="appconvex.html#cb15-13" tabindex="-1"></a>k1 <span class="op">=</span> np.zeros(<span class="dv">2</span>)</span>
<span id="cb15-14"><a href="appconvex.html#cb15-14" tabindex="-1"></a>c1 <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span></span>
<span id="cb15-15"><a href="appconvex.html#cb15-15" tabindex="-1"></a>K2 <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>]])</span>
<span id="cb15-16"><a href="appconvex.html#cb15-16" tabindex="-1"></a>k2 <span class="op">=</span> np.array([<span class="dv">2</span>, <span class="dv">2</span>])</span>
<span id="cb15-17"><a href="appconvex.html#cb15-17" tabindex="-1"></a>c2 <span class="op">=</span> <span class="fl">3.5</span></span>
<span id="cb15-18"><a href="appconvex.html#cb15-18" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> (if_ellipse(K1, k1, c1) <span class="kw">and</span> if_ellipse(K2, k2, c2)):</span>
<span id="cb15-19"><a href="appconvex.html#cb15-19" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&quot;The example setting is not correct&quot;</span>)</span>
<span id="cb15-20"><a href="appconvex.html#cb15-20" tabindex="-1"></a></span>
<span id="cb15-21"><a href="appconvex.html#cb15-21" tabindex="-1"></a><span class="co">## Step 1: define variables and parameters</span></span>
<span id="cb15-22"><a href="appconvex.html#cb15-22" tabindex="-1"></a>P0 <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>], [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>], [<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>], [<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>]])</span>
<span id="cb15-23"><a href="appconvex.html#cb15-23" tabindex="-1"></a>P1 <span class="op">=</span> np.zeros((<span class="dv">4</span>,<span class="dv">4</span>))</span>
<span id="cb15-24"><a href="appconvex.html#cb15-24" tabindex="-1"></a>P1[:<span class="dv">2</span>, :<span class="dv">2</span>] <span class="op">=</span> K1</span>
<span id="cb15-25"><a href="appconvex.html#cb15-25" tabindex="-1"></a>P2 <span class="op">=</span> np.zeros((<span class="dv">4</span>,<span class="dv">4</span>))</span>
<span id="cb15-26"><a href="appconvex.html#cb15-26" tabindex="-1"></a>P2[<span class="dv">2</span>:, <span class="dv">2</span>:] <span class="op">=</span> K2</span>
<span id="cb15-27"><a href="appconvex.html#cb15-27" tabindex="-1"></a>q1 <span class="op">=</span> np.concatenate([k1, np.zeros(<span class="dv">2</span>)])</span>
<span id="cb15-28"><a href="appconvex.html#cb15-28" tabindex="-1"></a>q2 <span class="op">=</span> np.concatenate([np.zeros(<span class="dv">2</span>), k2])</span>
<span id="cb15-29"><a href="appconvex.html#cb15-29" tabindex="-1"></a>r1 <span class="op">=</span> c1</span>
<span id="cb15-30"><a href="appconvex.html#cb15-30" tabindex="-1"></a>r2 <span class="op">=</span> c2</span>
<span id="cb15-31"><a href="appconvex.html#cb15-31" tabindex="-1"></a></span>
<span id="cb15-32"><a href="appconvex.html#cb15-32" tabindex="-1"></a><span class="co">## Step 2: define objective and constraints</span></span>
<span id="cb15-33"><a href="appconvex.html#cb15-33" tabindex="-1"></a>x <span class="op">=</span> cp.Variable(<span class="dv">4</span>) <span class="co"># variable: x = [y1, z1, y2, z2]^T</span></span>
<span id="cb15-34"><a href="appconvex.html#cb15-34" tabindex="-1"></a>fx <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> cp.quad_form(x, P0)</span>
<span id="cb15-35"><a href="appconvex.html#cb15-35" tabindex="-1"></a>obj <span class="op">=</span> cp.Minimize(fx)</span>
<span id="cb15-36"><a href="appconvex.html#cb15-36" tabindex="-1"></a>con1 <span class="op">=</span> (<span class="fl">0.5</span> <span class="op">*</span> cp.quad_form(x, P1) <span class="op">+</span> q1.T <span class="op">@</span> x <span class="op">+</span> r1 <span class="op">&lt;=</span> <span class="dv">0</span>) <span class="co"># ellipse 1</span></span>
<span id="cb15-37"><a href="appconvex.html#cb15-37" tabindex="-1"></a>con2 <span class="op">=</span> (<span class="fl">0.5</span> <span class="op">*</span> cp.quad_form(x, P2) <span class="op">+</span> q2.T <span class="op">@</span> x <span class="op">+</span> r2 <span class="op">&lt;=</span> <span class="dv">0</span>) <span class="co"># ellipse 2</span></span>
<span id="cb15-38"><a href="appconvex.html#cb15-38" tabindex="-1"></a>constraints <span class="op">=</span> [con1, con2]</span>
<span id="cb15-39"><a href="appconvex.html#cb15-39" tabindex="-1"></a>prob <span class="op">=</span> cp.Problem(obj, constraints) <span class="co"># form the problem</span></span>
<span id="cb15-40"><a href="appconvex.html#cb15-40" tabindex="-1"></a></span>
<span id="cb15-41"><a href="appconvex.html#cb15-41" tabindex="-1"></a><span class="co">## Step 3: solve problem and get results</span></span>
<span id="cb15-42"><a href="appconvex.html#cb15-42" tabindex="-1"></a>prob.solve()  </span>
<span id="cb15-43"><a href="appconvex.html#cb15-43" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;status: &quot;</span>, prob.status) <span class="co"># check whether the status is &quot;optimal&quot;</span></span>
<span id="cb15-44"><a href="appconvex.html#cb15-44" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;optimal value: &quot;</span>, prob.value) <span class="co"># optimal objective</span></span>
<span id="cb15-45"><a href="appconvex.html#cb15-45" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;optimal solution: &quot;</span>, x.value) <span class="co"># optimal x</span></span></code></pre></div>
</div>
<div id="socp" class="section level4 hasAnchor" number="4.2.7.4">
<h4><span class="header-section-number">A.2.7.4</span> SOCP<a href="appconvex.html#socp" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="appconvex.html#cb16-1" tabindex="-1"></a><span class="im">import</span> cvxpy <span class="im">as</span> cp</span>
<span id="cb16-2"><a href="appconvex.html#cb16-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-3"><a href="appconvex.html#cb16-3" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb16-4"><a href="appconvex.html#cb16-4" tabindex="-1"></a></span>
<span id="cb16-5"><a href="appconvex.html#cb16-5" tabindex="-1"></a><span class="co">## Define the SOCP example setting</span></span>
<span id="cb16-6"><a href="appconvex.html#cb16-6" tabindex="-1"></a><span class="co"># define bar_ai, bi (i = 1, 2, 3, 4)</span></span>
<span id="cb16-7"><a href="appconvex.html#cb16-7" tabindex="-1"></a>bar_a1 <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb16-8"><a href="appconvex.html#cb16-8" tabindex="-1"></a>b1 <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb16-9"><a href="appconvex.html#cb16-9" tabindex="-1"></a>bar_a2 <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb16-10"><a href="appconvex.html#cb16-10" tabindex="-1"></a>b2 <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb16-11"><a href="appconvex.html#cb16-11" tabindex="-1"></a>bar_a3 <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb16-12"><a href="appconvex.html#cb16-12" tabindex="-1"></a>b3 <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb16-13"><a href="appconvex.html#cb16-13" tabindex="-1"></a>bar_a4 <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb16-14"><a href="appconvex.html#cb16-14" tabindex="-1"></a>b4 <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb16-15"><a href="appconvex.html#cb16-15" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.1</span> </span>
<span id="cb16-16"><a href="appconvex.html#cb16-16" tabindex="-1"></a>c <span class="op">=</span> np.array([<span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb16-17"><a href="appconvex.html#cb16-17" tabindex="-1"></a>p <span class="op">=</span> <span class="fl">0.9</span> <span class="co"># p should be more than 0.5</span></span>
<span id="cb16-18"><a href="appconvex.html#cb16-18" tabindex="-1"></a></span>
<span id="cb16-19"><a href="appconvex.html#cb16-19" tabindex="-1"></a><span class="co">## Step 1: define variables and parameters</span></span>
<span id="cb16-20"><a href="appconvex.html#cb16-20" tabindex="-1"></a>Phi_inv <span class="op">=</span> norm.ppf(p) <span class="co"># get Phi^{-1}(p)</span></span>
<span id="cb16-21"><a href="appconvex.html#cb16-21" tabindex="-1"></a></span>
<span id="cb16-22"><a href="appconvex.html#cb16-22" tabindex="-1"></a><span class="co">## Step 2: define objective and constraints</span></span>
<span id="cb16-23"><a href="appconvex.html#cb16-23" tabindex="-1"></a>x <span class="op">=</span> cp.Variable(<span class="dv">2</span>) <span class="co"># variable: x = [x1, x2]^T</span></span>
<span id="cb16-24"><a href="appconvex.html#cb16-24" tabindex="-1"></a>obj <span class="op">=</span> cp.Minimize(c.T <span class="op">@</span> x)</span>
<span id="cb16-25"><a href="appconvex.html#cb16-25" tabindex="-1"></a><span class="co"># use cp.SOC(t, x) to create the SOC constraint ||x||_2 &lt;= t</span></span>
<span id="cb16-26"><a href="appconvex.html#cb16-26" tabindex="-1"></a>constraints <span class="op">=</span> [</span>
<span id="cb16-27"><a href="appconvex.html#cb16-27" tabindex="-1"></a>    cp.SOC(b1 <span class="op">-</span> bar_a1.T <span class="op">@</span> x, sigma<span class="op">*</span>Phi_inv<span class="op">*</span>x),</span>
<span id="cb16-28"><a href="appconvex.html#cb16-28" tabindex="-1"></a>    cp.SOC(b2 <span class="op">-</span> bar_a2.T <span class="op">@</span> x, sigma<span class="op">*</span>Phi_inv<span class="op">*</span>x),</span>
<span id="cb16-29"><a href="appconvex.html#cb16-29" tabindex="-1"></a>    cp.SOC(b3 <span class="op">-</span> bar_a3.T <span class="op">@</span> x, sigma<span class="op">*</span>Phi_inv<span class="op">*</span>x),</span>
<span id="cb16-30"><a href="appconvex.html#cb16-30" tabindex="-1"></a>    cp.SOC(b4 <span class="op">-</span> bar_a4.T <span class="op">@</span> x, sigma<span class="op">*</span>Phi_inv<span class="op">*</span>x),</span>
<span id="cb16-31"><a href="appconvex.html#cb16-31" tabindex="-1"></a>]</span>
<span id="cb16-32"><a href="appconvex.html#cb16-32" tabindex="-1"></a>prob <span class="op">=</span> cp.Problem(obj, constraints) <span class="co"># form the problem</span></span>
<span id="cb16-33"><a href="appconvex.html#cb16-33" tabindex="-1"></a></span>
<span id="cb16-34"><a href="appconvex.html#cb16-34" tabindex="-1"></a><span class="co">## Step 3: solve problem and get results</span></span>
<span id="cb16-35"><a href="appconvex.html#cb16-35" tabindex="-1"></a>prob.solve()  </span>
<span id="cb16-36"><a href="appconvex.html#cb16-36" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;status: &quot;</span>, prob.status) <span class="co"># check whether the status is &quot;optimal&quot;</span></span>
<span id="cb16-37"><a href="appconvex.html#cb16-37" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;optimal value: &quot;</span>, prob.value) <span class="co"># optimal objective</span></span>
<span id="cb16-38"><a href="appconvex.html#cb16-38" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;optimal solution: &quot;</span>, x.value) <span class="co"># optimal x</span></span></code></pre></div>
</div>
<div id="sdp" class="section level4 hasAnchor" number="4.2.7.5">
<h4><span class="header-section-number">A.2.7.5</span> SDP<a href="appconvex.html#sdp" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="appconvex.html#cb17-1" tabindex="-1"></a><span class="im">import</span> cvxpy <span class="im">as</span> cp</span>
<span id="cb17-2"><a href="appconvex.html#cb17-2" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb17-3"><a href="appconvex.html#cb17-3" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> ortho_group</span>
<span id="cb17-4"><a href="appconvex.html#cb17-4" tabindex="-1"></a></span>
<span id="cb17-5"><a href="appconvex.html#cb17-5" tabindex="-1"></a><span class="co">## Define the SDP example setting</span></span>
<span id="cb17-6"><a href="appconvex.html#cb17-6" tabindex="-1"></a><span class="co"># this function help to generate PD matrix of size 3*3 </span></span>
<span id="cb17-7"><a href="appconvex.html#cb17-7" tabindex="-1"></a><span class="co"># if you provide the eigenvalues [lam_1, lam_2, lam_3]</span></span>
<span id="cb17-8"><a href="appconvex.html#cb17-8" tabindex="-1"></a><span class="kw">def</span> generate_random_PD_matrix(lam_list):</span>
<span id="cb17-9"><a href="appconvex.html#cb17-9" tabindex="-1"></a>    <span class="cf">assert</span> np.<span class="bu">all</span>(lam_list <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="co"># all eigenvalues &gt;= 0</span></span>
<span id="cb17-10"><a href="appconvex.html#cb17-10" tabindex="-1"></a>    <span class="co"># S = Q @ D @ Q.T</span></span>
<span id="cb17-11"><a href="appconvex.html#cb17-11" tabindex="-1"></a>    D <span class="op">=</span> np.diag(lam_list)</span>
<span id="cb17-12"><a href="appconvex.html#cb17-12" tabindex="-1"></a>    Q <span class="op">=</span> ortho_group.rvs(<span class="dv">3</span>)</span>
<span id="cb17-13"><a href="appconvex.html#cb17-13" tabindex="-1"></a>    <span class="cf">return</span> Q <span class="op">@</span> D <span class="op">@</span> Q.T</span>
<span id="cb17-14"><a href="appconvex.html#cb17-14" tabindex="-1"></a>lam_list <span class="op">=</span> np.array([<span class="fl">0.5</span>, <span class="fl">2.4</span>, <span class="fl">3.7</span>])</span>
<span id="cb17-15"><a href="appconvex.html#cb17-15" tabindex="-1"></a>S <span class="op">=</span> generate_random_PD_matrix(lam_list) <span class="co"># get a PD matrix S</span></span>
<span id="cb17-16"><a href="appconvex.html#cb17-16" tabindex="-1"></a></span>
<span id="cb17-17"><a href="appconvex.html#cb17-17" tabindex="-1"></a><span class="co">## Step 1: define variables and parameters</span></span>
<span id="cb17-18"><a href="appconvex.html#cb17-18" tabindex="-1"></a><span class="co"># get coefficients for equality constraints</span></span>
<span id="cb17-19"><a href="appconvex.html#cb17-19" tabindex="-1"></a>A_00 <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]]) <span class="co"># tr(A_00 @ X) + lam = S_00</span></span>
<span id="cb17-20"><a href="appconvex.html#cb17-20" tabindex="-1"></a>A_01 <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]]) <span class="co"># tr(A_01 @ X) = S_01</span></span>
<span id="cb17-21"><a href="appconvex.html#cb17-21" tabindex="-1"></a>A_02 <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]]) <span class="co"># tr(A_02 @ X) = S_02</span></span>
<span id="cb17-22"><a href="appconvex.html#cb17-22" tabindex="-1"></a>A_11 <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]]) <span class="co"># tr(A_11 @ X) + lam = S_11</span></span>
<span id="cb17-23"><a href="appconvex.html#cb17-23" tabindex="-1"></a>A_12 <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]]) <span class="co"># tr(A_12 @ X) = S_12</span></span>
<span id="cb17-24"><a href="appconvex.html#cb17-24" tabindex="-1"></a>A_22 <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]]) <span class="co"># tr(A_22 @ X) + lam = S_22</span></span>
<span id="cb17-25"><a href="appconvex.html#cb17-25" tabindex="-1"></a></span>
<span id="cb17-26"><a href="appconvex.html#cb17-26" tabindex="-1"></a><span class="co">## Step 2: define objective and constraints</span></span>
<span id="cb17-27"><a href="appconvex.html#cb17-27" tabindex="-1"></a><span class="co"># define a PD matrix variable X of size 3*3</span></span>
<span id="cb17-28"><a href="appconvex.html#cb17-28" tabindex="-1"></a>X <span class="op">=</span> cp.Variable((<span class="dv">3</span>, <span class="dv">3</span>), symmetric<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-29"><a href="appconvex.html#cb17-29" tabindex="-1"></a>constraints <span class="op">=</span> [X <span class="op">&gt;&gt;</span> <span class="dv">0</span>] <span class="co"># the operator &gt;&gt; denotes matrix inequality</span></span>
<span id="cb17-30"><a href="appconvex.html#cb17-30" tabindex="-1"></a>lam <span class="op">=</span> cp.Variable(<span class="dv">1</span>)</span>
<span id="cb17-31"><a href="appconvex.html#cb17-31" tabindex="-1"></a>constraints <span class="op">+=</span> [</span>
<span id="cb17-32"><a href="appconvex.html#cb17-32" tabindex="-1"></a>    cp.trace(A_00 <span class="op">@</span> X) <span class="op">+</span> lam <span class="op">==</span> S[<span class="dv">0</span>,<span class="dv">0</span>],</span>
<span id="cb17-33"><a href="appconvex.html#cb17-33" tabindex="-1"></a>    cp.trace(A_01 <span class="op">@</span> X) <span class="op">==</span> S[<span class="dv">0</span>,<span class="dv">1</span>],</span>
<span id="cb17-34"><a href="appconvex.html#cb17-34" tabindex="-1"></a>    cp.trace(A_02 <span class="op">@</span> X) <span class="op">==</span> S[<span class="dv">0</span>,<span class="dv">2</span>],</span>
<span id="cb17-35"><a href="appconvex.html#cb17-35" tabindex="-1"></a>    cp.trace(A_11 <span class="op">@</span> X) <span class="op">+</span> lam <span class="op">==</span> S[<span class="dv">1</span>,<span class="dv">1</span>],</span>
<span id="cb17-36"><a href="appconvex.html#cb17-36" tabindex="-1"></a>    cp.trace(A_12 <span class="op">@</span> X) <span class="op">==</span> S[<span class="dv">1</span>,<span class="dv">2</span>],</span>
<span id="cb17-37"><a href="appconvex.html#cb17-37" tabindex="-1"></a>    cp.trace(A_22 <span class="op">@</span> X) <span class="op">+</span> lam <span class="op">==</span> S[<span class="dv">2</span>,<span class="dv">2</span>],</span>
<span id="cb17-38"><a href="appconvex.html#cb17-38" tabindex="-1"></a>]</span>
<span id="cb17-39"><a href="appconvex.html#cb17-39" tabindex="-1"></a>obj <span class="op">=</span> cp.Minimize(<span class="op">-</span>lam)</span>
<span id="cb17-40"><a href="appconvex.html#cb17-40" tabindex="-1"></a>prob <span class="op">=</span> cp.Problem(obj, constraints) <span class="co"># form the problem</span></span>
<span id="cb17-41"><a href="appconvex.html#cb17-41" tabindex="-1"></a></span>
<span id="cb17-42"><a href="appconvex.html#cb17-42" tabindex="-1"></a><span class="co">## Step 3: solve problem and get results</span></span>
<span id="cb17-43"><a href="appconvex.html#cb17-43" tabindex="-1"></a>prob.solve()  </span>
<span id="cb17-44"><a href="appconvex.html#cb17-44" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;status: &quot;</span>, prob.status) <span class="co"># check whether the status is &quot;optimal&quot;</span></span>
<span id="cb17-45"><a href="appconvex.html#cb17-45" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;optimal value: &quot;</span>, prob.value) <span class="co"># optimal objective</span></span>
<span id="cb17-46"><a href="appconvex.html#cb17-46" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;optimal solution: &quot;</span>, lam.value) <span class="co"># optimal lam</span></span></code></pre></div>

</div>
</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="policy-gradient.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="app-lti-system-theory.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
  "sharing": {
    "github": false,
    "facebook": true,
    "twitter": true,
    "linkedin": false,
    "weibo": false,
    "instapaper": false,
    "vk": false,
    "whatsapp": false,
    "all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
  },
  "fontsettings": {
    "theme": "white",
    "family": "sans",
    "size": 2
  },
  "edit": {
    "link": "https://github.com/hankyang94/OptimalControlReinforcementLearning/blob/main/11-2-appendix-convex.Rmd",
    "text": "Edit"
  },
  "history": {
    "link": null,
    "text": null
  },
  "view": {
    "link": null,
    "text": null
  },
  "download": ["optimal-control-reinforcement-learning.pdf"],
  "search": {
    "engine": "fuse",
    "options": null
  },
  "toc": {
    "collapse": "subsection"
  }
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
